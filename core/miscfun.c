   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  08/25/16             */
   /*                                                     */
   /*            MISCELLANEOUS FUNCTIONS MODULE           */
   /*******************************************************/

/*************************************************************/
/* Purpose:                                                  */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Gary D. Riley                                        */
/*                                                           */
/* Contributing Programmer(s):                               */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Revision History:                                         */
/*                                                           */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable exp to theExp         */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Removed CONFLICT_RESOLUTION_STRATEGIES,        */
/*            DYNAMIC_SALIENCE, INCREMENTAL_RESET,           */
/*            LOGICAL_DEPENDENCIES, IMPERATIVE_METHODS       */
/*            INSTANCE_PATTERN_MATCHING,                     */
/*            IMPERATIVE_MESSAGE_HANDLERS, and               */
/*            AUXILIARY_MESSAGE_HANDLERS compilation flags.  */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*      6.30: Support for long long integers.                */
/*                                                           */
/*            Used gensprintf instead of sprintf.            */
/*                                                           */
/*            Removed conditional code for unsupported       */
/*            compilers/operating systems.                   */
/*                                                           */
/*            Renamed EX_MATH compiler flag to               */
/*            EXTENDED_MATH_FUNCTIONS.                       */
/*                                                           */
/*            Combined BASIC_IO and EXT_IO compilation       */
/*            flags into the IO_FUNCTIONS compilation flag.  */
/*                                                           */    
/*            Removed code associated with HELP_FUNCTIONS    */
/*            and EMACS_EDITOR compiler flags.               */
/*                                                           */    
/*            Added operating-system function.               */
/*                                                           */ 
/*            Added new function (for future use).           */
/*                                                           */ 
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Removed deallocating message parameter from    */
/*            EnvReleaseMem.                                 */
/*                                                           */
/*            Removed support for BLOCK_MEMORY.              */
/*                                                           */
/*      6.31: Added local-time and gm-time functions.        */
/*                                                           */
/*      6.40: Changed restrictions from char * to            */
/*            symbolHashNode * to support strings            */
/*            originating from sources that are not          */
/*            statically allocated.                          */
/*                                                           */
/*            Added Env prefix to GetEvaluationError and     */
/*            SetEvaluationError functions.                  */
/*                                                           */
/*            Added Env prefix to GetHaltExecution and       */
/*            SetHaltExecution functions.                    */
/*                                                           */
/*            Refactored code to reduce header dependencies  */
/*            in sysdep.c.                                   */
/*                                                           */
/*            Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            Removed VAX_VMS support.                       */
/*                                                           */
/*            Removed mv-append and length functions.        */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*************************************************************/

#include <stdio.h>
#include <string.h>
#include <time.h>

#include "setup.h"

#include "argacces.h"
#include "envrnmnt.h"
#include "exprnpsr.h"
#include "memalloc.h"
#include "multifld.h"
#include "router.h"
#include "sysdep.h"
#include "utility.h"

#if DEFFUNCTION_CONSTRUCT
#include "dffnxfun.h"
#endif

#if DEFTEMPLATE_CONSTRUCT
#include "factfun.h"
#include "tmpltutl.h"
#endif

#include "miscfun.h"

#define MISCFUN_DATA 9

struct miscFunctionData
  { 
   long long GensymNumber;
  };

#define MiscFunctionData(theEnv) ((struct miscFunctionData *) GetEnvironmentData(theEnv,MISCFUN_DATA))

/***************************************/
/* LOCAL INTERNAL FUNCTION DEFINITIONS */
/***************************************/

   static void                    ExpandFuncMultifield(Environment *,CLIPSValue *,EXPRESSION *,
                                                       EXPRESSION **,void *);
   static int                     FindLanguageType(Environment *,const char *);
   static void                    ConvertTime(Environment *,CLIPSValue *,struct tm *);

/*****************************************************************/
/* MiscFunctionDefinitions: Initializes miscellaneous functions. */
/*****************************************************************/
void MiscFunctionDefinitions(
  Environment *theEnv)
  {
   AllocateEnvironmentData(theEnv,MISCFUN_DATA,sizeof(struct miscFunctionData),NULL);
   MiscFunctionData(theEnv)->GensymNumber = 1;
   
#if ! RUN_TIME
   EnvAddUDF(theEnv,"gensym","y",0,0,NULL,GensymFunction,"GensymFunction",NULL);
   EnvAddUDF(theEnv,"gensym*","y",0,0,NULL,GensymStarFunction,"GensymStarFunction",NULL);
   EnvAddUDF(theEnv,"setgen","l",1,1,"l",SetgenFunction,"SetgenFunction",NULL);
   
   EnvAddUDF(theEnv,"system","v",1,UNBOUNDED,"sy",SystemCommand,"SystemCommand",NULL);
   EnvAddUDF(theEnv,"length$","l",1,1,"sym",LengthFunction,"LengthFunction",NULL);
   EnvAddUDF(theEnv,"time","d",0,0,NULL,TimeFunction,"TimeFunction",NULL);
   EnvAddUDF(theEnv,"local-time","m",0,0,NULL,LocalTimeFunction,"LocalTimeFunction",NULL);
   EnvAddUDF(theEnv,"gm-time","m",0,0,NULL,GMTimeFunction,"GMTimeFunction",NULL);

   EnvAddUDF(theEnv,"random","l",0,2,"l",RandomFunction,"RandomFunction",NULL);
   EnvAddUDF(theEnv,"seed","v",1,1,"l",SeedFunction,"SeedFunction",NULL);
   EnvAddUDF(theEnv,"conserve-mem","v",1,1,"y",ConserveMemCommand,"ConserveMemCommand",NULL);
   EnvAddUDF(theEnv,"release-mem","l",0,0,NULL,ReleaseMemCommand,"ReleaseMemCommand",NULL);
#if DEBUGGING_FUNCTIONS
   EnvAddUDF(theEnv,"mem-used","l",0,0,NULL,MemUsedCommand,"MemUsedCommand",NULL);
   EnvAddUDF(theEnv,"mem-requests","l",0,0,NULL,MemRequestsCommand,"MemRequestsCommand",NULL);
#endif

   EnvAddUDF(theEnv,"options","v",0,0,NULL,OptionsCommand,"OptionsCommand",NULL);

   EnvAddUDF(theEnv,"operating-system","y",0,0,NULL,OperatingSystemFunction,"OperatingSystemFunction",NULL);
   EnvAddUDF(theEnv,"(expansion-call)","*",0,UNBOUNDED,NULL,ExpandFuncCall,"ExpandFuncCall",NULL);
   EnvAddUDF(theEnv,"expand$","*",1,1,"m",DummyExpandFuncMultifield,"DummyExpandFuncMultifield",NULL);
   FuncSeqOvlFlags(theEnv,"expand$",false,false);
   EnvAddUDF(theEnv,"(set-evaluation-error)","y",0,0,NULL,CauseEvaluationError,"CauseEvaluationError",NULL);
   EnvAddUDF(theEnv,"set-sequence-operator-recognition","b",1,1,"y",SetSORCommand,"SetSORCommand",NULL);
   EnvAddUDF(theEnv,"get-sequence-operator-recognition","b",0,0,NULL,GetSORCommand,"GetSORCommand",NULL);
   EnvAddUDF(theEnv,"get-function-restrictions","s",1,1,"y",GetFunctionRestrictions,"GetFunctionRestrictions",NULL);
   EnvAddUDF(theEnv,"create$","m",0,UNBOUNDED,NULL,CreateFunction,"CreateFunction",NULL);
   EnvAddUDF(theEnv,"apropos","v",1,1,"y",AproposCommand,"AproposCommand",NULL);
   EnvAddUDF(theEnv,"get-function-list","m",0,0,NULL,GetFunctionListFunction,"GetFunctionListFunction",NULL);
   EnvAddUDF(theEnv,"funcall","*",1,UNBOUNDED,"*;sy",FuncallFunction,"FuncallFunction",NULL);
   EnvAddUDF(theEnv,"new","*",1,UNBOUNDED,"*;y",NewFunction,"NewFunction",NULL);
   EnvAddUDF(theEnv,"call","*",1,UNBOUNDED,"*",CallFunction,"CallFunction",NULL);
   EnvAddUDF(theEnv,"timer","d",0,UNBOUNDED,NULL,TimerFunction,"TimerFunction",NULL);
#endif
  }

/******************************************************************/
/* CreateFunction: H/L access routine for the create$ function.   */
/******************************************************************/
void CreateFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   StoreInMultifield(theEnv,returnValue,GetFirstArgument(),true);
  }

/*****************************************************************/
/* SetgenFunction: H/L access routine for the setgen function.   */
/*****************************************************************/
void SetgenFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   long long theLong;

   /*==========================================================*/
   /* Check to see that a single integer argument is provided. */
   /*==========================================================*/

   if (! UDFNthArgument(context,1,INTEGER_TYPE,returnValue))
     { return; }

   /*========================================*/
   /* The integer must be greater than zero. */
   /*========================================*/

   theLong = ValueToLong(returnValue->value);

   if (theLong < 1LL)
     {
      UDFInvalidArgumentMessage(context,"integer (greater than or equal to 1)");
      returnValue->type = INTEGER;
      returnValue->value = EnvAddLong(theEnv,MiscFunctionData(theEnv)->GensymNumber);
      return;
     }

   /*====================================*/
   /* Set the gensym index to the number */
   /* provided and return this value.    */
   /*====================================*/

   MiscFunctionData(theEnv)->GensymNumber = theLong;
  }

/****************************************/
/* GensymFunction: H/L access routine   */
/*   for the gensym function.           */
/****************************************/
void GensymFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   char genstring[128];
   
   returnValue->type = SYMBOL;
   
   /*================================================*/
   /* Create a symbol using the current gensym index */
   /* as the postfix.                                */
   /*================================================*/

   gensprintf(genstring,"gen%lld",MiscFunctionData(theEnv)->GensymNumber);
   MiscFunctionData(theEnv)->GensymNumber++;

   /*====================*/
   /* Return the symbol. */
   /*====================*/

   returnValue->value = EnvAddSymbol(theEnv,genstring);
  }

/************************************************/
/* GensymStarFunction: H/L access routine for   */
/*   the gensym* function.                      */
/************************************************/
void GensymStarFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*====================*/
   /* Return the symbol. */
   /*====================*/

   returnValue->type = SYMBOL;
   returnValue->value = GensymStar(theEnv);
  }

/************************************/
/* GensymStar: C access routine for */
/*   the gensym* function.          */
/************************************/
void *GensymStar(
  Environment *theEnv)
  {
   char genstring[128];
   
   /*=======================================================*/
   /* Create a symbol using the current gensym index as the */
   /* postfix. If the symbol is already present in the      */
   /* symbol table, then continue generating symbols until  */
   /* a unique symbol is found.                             */
   /*=======================================================*/

   do
     {
      gensprintf(genstring,"gen%lld",MiscFunctionData(theEnv)->GensymNumber);
      MiscFunctionData(theEnv)->GensymNumber++;
     }
   while (FindSymbolHN(theEnv,genstring) != NULL);

   /*====================*/
   /* Return the symbol. */
   /*====================*/

   return(EnvAddSymbol(theEnv,genstring));
  }

/********************************************/
/* RandomFunction: H/L access routine for   */
/*   the random function.                   */
/********************************************/
void RandomFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int argCount;
   long long rv;
   CLIPSValue theArg;
   long long begin, end;

   returnValue->type = INTEGER;
   
   /*====================================*/
   /* The random function accepts either */
   /* zero or two arguments.             */
   /*====================================*/

   argCount = UDFArgumentCount(context);
   
   if ((argCount != 0) && (argCount != 2))
     {
      PrintErrorID(theEnv,"MISCFUN",2,false);
      EnvPrintRouter(theEnv,WERROR,"Function random expected either 0 or 2 arguments\n"); 
     }

   /*========================================*/
   /* Return the randomly generated integer. */
   /*========================================*/

   rv = genrand();
   
   if (argCount == 2)
     {
      if (! UDFFirstArgument(context,INTEGER_TYPE,&theArg))
        { return; }
        
      begin = DOToLong(theArg);
      if (! UDFNextArgument(context,INTEGER_TYPE,&theArg))
        { return; }

      end = DOToLong(theArg);
      if (end < begin)
        {
         PrintErrorID(theEnv,"MISCFUN",3,false);
         EnvPrintRouter(theEnv,WERROR,"Function random expected argument #1 to be less than argument #2\n"); 
         returnValue->value = EnvAddLong(theEnv,rv);
         return;
        }
        
      rv = begin + (rv % ((end - begin) + 1));
     }
   
   returnValue->value = EnvAddLong(theEnv,rv);
  }

/******************************************/
/* SeedFunction: H/L access routine for   */
/*   the seed function.                   */
/******************************************/
void SeedFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theValue;

   /*==========================================================*/
   /* Check to see that a single integer argument is provided. */
   /*==========================================================*/

   if (! UDFFirstArgument(context,INTEGER_TYPE,&theValue))
     { return; }

   /*=============================================================*/
   /* Seed the random number generator with the provided integer. */
   /*=============================================================*/

   genseed((int) DOToLong(theValue));
  }

/********************************************/
/* LengthFunction: H/L access routine for   */
/*   the length$ function.                  */
/********************************************/
void LengthFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;

   returnValue->type = INTEGER;
   
   /*====================================================*/
   /* The length$ function expects exactly one argument. */
   /*====================================================*/

   if (! UDFFirstArgument(context, LEXEME_TYPES | MULTIFIELD_TYPE, &theArg))
     { return; }

   /*====================================================*/
   /* If the argument is a string or symbol, then return */
   /* the number of characters in the argument.          */
   /*====================================================*/

   if ((GetType(theArg) == STRING) || (GetType(theArg) == SYMBOL))
     {
      returnValue->value = EnvAddLong(theEnv,strlen(DOToString(theArg)));
      return;
     }

   /*====================================================*/
   /* If the argument is a multifield value, then return */
   /* the number of fields in the argument.              */
   /*====================================================*/

   if (GetType(theArg) == MULTIFIELD)
     {
      returnValue->value = EnvAddLong(theEnv,GetDOLength(theArg));
      return;
     }

   /*=============================================*/
   /* If the argument wasn't a string, symbol, or */
   /* multifield value, then generate an error.   */
   /*=============================================*/

   EnvSetEvaluationError(theEnv,true);
   ExpectedTypeError2(theEnv,"length$",1);
   returnValue->value = EnvAddLong(theEnv,-1);
  }

/*******************************************/
/* ReleaseMemCommand: H/L access routine   */
/*   for the release-mem function.         */
/*******************************************/
void ReleaseMemCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*========================================*/
   /* Release memory to the operating system */
   /* and return the amount of memory freed. */
   /*========================================*/

   returnValue->type = INTEGER;
   returnValue->value = EnvAddLong(theEnv,EnvReleaseMem(theEnv,-1L));
  }

/******************************************/
/* ConserveMemCommand: H/L access routine */
/*   for the conserve-mem command.        */
/******************************************/
void ConserveMemCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   const char *argument;
   CLIPSValue theValue;

   /*===================================*/
   /* The conserve-mem function expects */
   /* a single symbol argument.         */
   /*===================================*/

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theValue))
     { return; }

   argument = DOToString(theValue);

   /*====================================================*/
   /* If the argument is the symbol "on", then store the */
   /* pretty print representation of a construct when it */
   /* is defined.                                        */
   /*====================================================*/

   if (strcmp(argument,"on") == 0)
     { EnvSetConserveMemory(theEnv,true); }

   /*======================================================*/
   /* Otherwise, if the argument is the symbol "off", then */
   /* don't store the pretty print representation of a     */
   /* construct when it is defined.                        */
   /*======================================================*/

   else if (strcmp(argument,"off") == 0)
     { EnvSetConserveMemory(theEnv,false); }

   /*=====================================================*/
   /* Otherwise, generate an error since the only allowed */
   /* arguments are "on" or "off."                        */
   /*=====================================================*/

   else
     {
      UDFInvalidArgumentMessage(context,"symbol with value on or off");
      return;
     }

   return;
  }

#if DEBUGGING_FUNCTIONS

/****************************************/
/* MemUsedCommand: H/L access routine   */
/*   for the mem-used command.          */
/****************************************/
void MemUsedCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   returnValue->type = INTEGER;
   
   /*============================================*/
   /* Return the amount of memory currently held */
   /* (both for current use and for later use).  */
   /*============================================*/

   returnValue->value = EnvAddLong(theEnv,EnvMemUsed(theEnv));
  }

/********************************************/
/* MemRequestsCommand: H/L access routine   */
/*   for the mem-requests command.          */
/********************************************/
void MemRequestsCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   returnValue->type = INTEGER;
   
   /*==================================*/
   /* Return the number of outstanding */
   /* memory requests.                 */
   /*==================================*/

   returnValue->value = EnvAddLong(theEnv,EnvMemRequests(theEnv));
  }

#endif

/****************************************/
/* AproposCommand: H/L access routine   */
/*   for the apropos command.           */
/****************************************/
void AproposCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   const char *argument;
   CLIPSValue theArg;
   struct symbolHashNode *hashPtr = NULL;
   size_t theLength;

   /*=======================================================*/
   /* The apropos command expects a single symbol argument. */
   /*=======================================================*/

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
     { return; }

   /*=======================================*/
   /* Determine the length of the argument. */
   /*=======================================*/

   argument = DOToString(theArg);
   theLength = strlen(argument);

   /*====================================================================*/
   /* Print each entry in the symbol table that contains the argument as */
   /* a substring. When using a non-ANSI compiler, only those strings    */
   /* that contain the substring starting at the beginning of the string */
   /* are printed.                                                       */
   /*====================================================================*/

   while ((hashPtr = GetNextSymbolMatch(theEnv,argument,theLength,hashPtr,true,NULL)) != NULL)
     {
      EnvPrintRouter(theEnv,WDISPLAY,ValueToString(hashPtr));
      EnvPrintRouter(theEnv,WDISPLAY,"\n");
     }
  }

/****************************************/
/* OptionsCommand: H/L access routine   */
/*   for the options command.           */
/****************************************/
void OptionsCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*=================================*/
   /* Print the state of the compiler */
   /* flags for this executable.      */
   /*=================================*/

   EnvPrintRouter(theEnv,WDISPLAY,"Machine type: ");

#if GENERIC
   EnvPrintRouter(theEnv,WDISPLAY,"Generic ");
#endif
#if UNIX_V
   EnvPrintRouter(theEnv,WDISPLAY,"UNIX System V or 4.2BSD ");
#endif
#if DARWIN
   EnvPrintRouter(theEnv,WDISPLAY,"Darwin ");
#endif
#if LINUX
   EnvPrintRouter(theEnv,WDISPLAY,"Linux ");
#endif
#if UNIX_7
   EnvPrintRouter(theEnv,WDISPLAY,"UNIX System III Version 7 or Sun Unix ");
#endif
#if MAC_XCD
   EnvPrintRouter(theEnv,WDISPLAY,"Apple Macintosh with Xcode");
#endif
#if WIN_MVC
   EnvPrintRouter(theEnv,WDISPLAY,"Microsoft Windows with Microsoft Visual C++");
#endif
#if WIN_GCC
   EnvPrintRouter(theEnv,WDISPLAY,"Microsoft Windows with DJGPP");
#endif
EnvPrintRouter(theEnv,WDISPLAY,"\n");

EnvPrintRouter(theEnv,WDISPLAY,"Defrule construct is ");
#if DEFRULE_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Defmodule construct is ");
#if DEFMODULE_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Deftemplate construct is ");
#if DEFTEMPLATE_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Fact-set queries are ");
#if FACT_SET_QUERIES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#if DEFTEMPLATE_CONSTRUCT

EnvPrintRouter(theEnv,WDISPLAY,"  Deffacts construct is ");
#if DEFFACTS_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#endif

EnvPrintRouter(theEnv,WDISPLAY,"Defglobal construct is ");
#if DEFGLOBAL_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Deffunction construct is ");
#if DEFFUNCTION_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Defgeneric/Defmethod constructs are ");
#if DEFGENERIC_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Object System is ");
#if OBJECT_SYSTEM
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#if OBJECT_SYSTEM

EnvPrintRouter(theEnv,WDISPLAY,"  Definstances construct is ");
#if DEFINSTANCES_CONSTRUCT
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Instance-set queries are ");
#if INSTANCE_SET_QUERIES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Binary loading of instances is ");
#if BLOAD_INSTANCES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"  Binary saving of instances is ");
#if BSAVE_INSTANCES
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

#endif

EnvPrintRouter(theEnv,WDISPLAY,"Extended math function package is ");
#if EXTENDED_MATH_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Text processing function package is ");
#if TEXTPRO_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Bload capability is ");
#if BLOAD_ONLY
  EnvPrintRouter(theEnv,WDISPLAY,"BLOAD ONLY");
#endif
#if BLOAD
  EnvPrintRouter(theEnv,WDISPLAY,"BLOAD");
#endif
#if BLOAD_AND_BSAVE
  EnvPrintRouter(theEnv,WDISPLAY,"BLOAD AND BSAVE");
#endif
#if (! BLOAD_ONLY) && (! BLOAD) && (! BLOAD_AND_BSAVE)
  EnvPrintRouter(theEnv,WDISPLAY,"OFF ");
#endif
EnvPrintRouter(theEnv,WDISPLAY,"\n");

EnvPrintRouter(theEnv,WDISPLAY,"Construct compiler is ");
#if CONSTRUCT_COMPILER
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"I/O function package is ");
#if IO_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"String function package is ");
#if STRING_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Multifield function package is ");
#if MULTIFIELD_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Debugging function package is ");
#if DEBUGGING_FUNCTIONS
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Window Interface flag is ");
#if WINDOW_INTERFACE
   EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
   EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Developer flag is ");
#if DEVELOPER
   EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
   EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif

EnvPrintRouter(theEnv,WDISPLAY,"Run time module is ");
#if RUN_TIME
  EnvPrintRouter(theEnv,WDISPLAY,"ON\n");
#else
  EnvPrintRouter(theEnv,WDISPLAY,"OFF\n");
#endif
  }

/***********************************************/
/* OperatingSystemFunction: H/L access routine */
/*   for the operating system function.        */
/***********************************************/
void OperatingSystemFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   returnValue->type = SYMBOL;
#if GENERIC
   returnValue->value = EnvAddSymbol(theEnv,"UNKNOWN");
#elif UNIX_V
   returnValue->value = EnvAddSymbol(theEnv,"UNIX-V");
#elif UNIX_7
   returnValue->value = EnvAddSymbol(theEnv,"UNIX-7");
#elif LINUX
   returnValue->value = EnvAddSymbol(theEnv,"LINUX");
#elif DARWIN
   returnValue->value = EnvAddSymbol(theEnv,"DARWIN");
#elif MAC_XCD
   returnValue->value = EnvAddSymbol(theEnv,"MAC-OS-X");
#elif IBM && (! WINDOW_INTERFACE)
   returnValue->value = EnvAddSymbol(theEnv,"DOS");
#elif IBM && WINDOW_INTERFACE
   returnValue->value = EnvAddSymbol(theEnv,"WINDOWS");
#else
   returnValue->value = EnvAddSymbol(theEnv,"UNKNOWN");
#endif
  }
  
/********************************************************************
  NAME         : ExpandFuncCall
  DESCRIPTION  : This function is a wrap-around for a normal
                   function call.  It preexamines the argument
                   expression list and expands any references to the
                   sequence operator.  It builds a copy of the
                   function call expression with these new arguments
                   inserted and evaluates the function call.
  INPUTS       : A data object buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : Expressions alloctaed/deallocated
                 Function called and arguments evaluated
                 EvaluationError set on errors
  NOTES        : None
 *******************************************************************/
void ExpandFuncCall(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   EXPRESSION *newargexp,*fcallexp;
   struct FunctionDefinition *func;

   /* ======================================================================
      Copy the original function call's argument expression list.
      Look for expand$ function callsexpressions and replace those
        with the equivalent expressions of the expansions of evaluations
        of the arguments.
      ====================================================================== */
   newargexp = CopyExpression(theEnv,GetFirstArgument()->argList);
   ExpandFuncMultifield(theEnv,returnValue,newargexp,&newargexp,
                        FindFunction(theEnv,"expand$"));

   /* ===================================================================
      Build the new function call expression with the expanded arguments.
      Check the number of arguments, if necessary, and call the thing.
      =================================================================== */
   fcallexp = get_struct(theEnv,expr);
   fcallexp->type = GetFirstArgument()->type;
   fcallexp->value = GetFirstArgument()->value;
   fcallexp->nextArg = NULL;
   fcallexp->argList = newargexp;
   if (fcallexp->type == FCALL)
     {
      func = (struct FunctionDefinition *) fcallexp->value;
      if (CheckFunctionArgCount(theEnv,func,CountArguments(newargexp)) == false)
        {
         returnValue->type = SYMBOL;
         returnValue->value = EnvFalseSymbol(theEnv);
         ReturnExpression(theEnv,fcallexp);
         return;
        }
     }
#if DEFFUNCTION_CONSTRUCT
   else if (fcallexp->type == PCALL)
     {
      if (CheckDeffunctionCall(theEnv,fcallexp->value,
              CountArguments(fcallexp->argList)) == false)
        {
         returnValue->type = SYMBOL;
         returnValue->value = EnvFalseSymbol(theEnv);
         ReturnExpression(theEnv,fcallexp);
         EnvSetEvaluationError(theEnv,true);
         return;
        }
     }
#endif

   EvaluateExpression(theEnv,fcallexp,returnValue);
   ReturnExpression(theEnv,fcallexp);
  }

/***********************************************************************
  NAME         : DummyExpandFuncMultifield
  DESCRIPTION  : The expansion of multifield arguments is valid only
                 when done for a function call.  All these expansions
                 are handled by the H/L wrap-around function
                 (expansion-call) - see ExpandFuncCall.  If the H/L
                 function, epand-multifield is ever called directly,
                 it is an error.
  INPUTS       : Data object buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : EvaluationError set
  NOTES        : None
 **********************************************************************/
void DummyExpandFuncMultifield(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   returnValue->type = SYMBOL;
   returnValue->value = EnvFalseSymbol(theEnv);
   EnvSetEvaluationError(theEnv,true);
   PrintErrorID(theEnv,"MISCFUN",1,false);
   EnvPrintRouter(theEnv,WERROR,"expand$ must be used in the argument list of a function call.\n");
  }

/***********************************************************************
  NAME         : ExpandFuncMultifield
  DESCRIPTION  : Recursively examines an expression and replaces
                   PROC_EXPAND_MULTIFIELD expressions with the expanded
                   evaluation expression of its argument
  INPUTS       : 1) A data object result buffer
                 2) The expression to modify
                 3) The address of the expression, in case it is
                    deleted entirely
                 4) The address of the H/L function expand$
  RETURNS      : Nothing useful
  SIDE EFFECTS : Expressions allocated/deallocated as necessary
                 Evaluations performed
                 On errors, argument expression set to call a function
                   which causes an evaluation error when evaluated
                   a second time by actual caller.
  NOTES        : THIS ROUTINE MODIFIES EXPRESSIONS AT RUNTIME!!  MAKE
                 SURE THAT THE EXPRESSION PASSED IS SAFE TO CHANGE!!
 **********************************************************************/
static void ExpandFuncMultifield(
  Environment *theEnv,
  CLIPSValue *returnValue,
  EXPRESSION *theExp,
  EXPRESSION **sto,
  void *expmult)
  {
   EXPRESSION *newexp,*top,*bot;
   long i; /* 6.04 Bug Fix */

   while (theExp != NULL)
     {
      if (theExp->value == expmult)
        {
         EvaluateExpression(theEnv,theExp->argList,returnValue);
         ReturnExpression(theEnv,theExp->argList);
         if ((EvaluationData(theEnv)->EvaluationError) || (returnValue->type != MULTIFIELD))
           {
            theExp->argList = NULL;
            if ((EvaluationData(theEnv)->EvaluationError == false) && (returnValue->type != MULTIFIELD))
              ExpectedTypeError2(theEnv,"expand$",1);
            theExp->value = FindFunction(theEnv,"(set-evaluation-error)");
            EvaluationData(theEnv)->EvaluationError = false;
            EvaluationData(theEnv)->HaltExecution = false;
            return;
           }
         top = bot = NULL;
         for (i = GetpDOBegin(returnValue) ; i <= GetpDOEnd(returnValue) ; i++)
           {
            newexp = get_struct(theEnv,expr);
            newexp->type = GetMFType(returnValue->value,i);
            newexp->value = GetMFValue(returnValue->value,i);
            newexp->argList = NULL;
            newexp->nextArg = NULL;
            if (top == NULL)
              top = newexp;
            else
              bot->nextArg = newexp;
            bot = newexp;
           }
         if (top == NULL)
           {
            *sto = theExp->nextArg;
            rtn_struct(theEnv,expr,theExp);
            theExp = *sto;
           }
         else
           {
            bot->nextArg = theExp->nextArg;
            *sto = top;
            rtn_struct(theEnv,expr,theExp);
            sto = &bot->nextArg;
            theExp = bot->nextArg;
           }
        }
      else
        {
         if (theExp->argList != NULL)
           ExpandFuncMultifield(theEnv,returnValue,theExp->argList,&theExp->argList,expmult);
         sto = &theExp->nextArg;
         theExp = theExp->nextArg;
        }
     }
  }

/****************************************************************
  NAME         : CauseEvaluationError
  DESCRIPTION  : Dummy function use to cause evaluation errors on
                   a function call to generate error messages
  INPUTS       : None
  RETURNS      : A pointer to the FalseSymbol
  SIDE EFFECTS : EvaluationError set
  NOTES        : None
 ****************************************************************/
void CauseEvaluationError(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   EnvSetEvaluationError(theEnv,true);
   returnValue->type = SYMBOL;
   returnValue->value = EnvFalseSymbol(theEnv);
  }

/************************************************/
/* GetSORCommand: H/L access routine for the    */
/*   get-sequence-operator-recognition command. */
/************************************************/
void GetSORCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*========================================*/
   /* Get the current value of the behavior. */
   /*========================================*/

   returnValue->type = SYMBOL;
   if (EnvGetSequenceOperatorRecognition(theEnv))
     { returnValue->value = EnvTrueSymbol(theEnv); }
   else
     { returnValue->value = EnvFalseSymbol(theEnv); }
  }

/************************************************/
/* SetSORCommand: H/L access routine for the    */
/*   set-sequence-operator-recognition command. */
/************************************************/
void SetSORCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
#if (! RUN_TIME) && (! BLOAD_ONLY)
   CLIPSValue theArg;

   returnValue->type = SYMBOL;
   if (ExpressionData(theEnv)->SequenceOpMode)
     { returnValue->value = EnvTrueSymbol(theEnv); }
   else
     { returnValue->value = EnvFalseSymbol(theEnv); }
   
   /*========================*/
   /* Evaluate the argument. */
   /*========================*/

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
     { return; }

   /*================================================*/
   /* If the argument evaluated to false, then the   */
   /* behavior is disabled, otherwise it is enabled. */
   /*================================================*/

   if ((theArg.value == EnvFalseSymbol(theEnv)) && (theArg.type == SYMBOL))
     { EnvSetSequenceOperatorRecognition(theEnv,false); }
   else
     { EnvSetSequenceOperatorRecognition(theEnv,true); }
#else
   returnValue->type = SYMBOL;
   if (ExpressionData(theEnv)->SequenceOpMode)
     { returnValue->value = EnvTrueSymbol(theEnv); }
   else
     { returnValue->value = EnvFalseSymbol(theEnv); }
#endif
  }

/********************************************************************
  NAME         : GetFunctionRestrictions
  DESCRIPTION  : Gets DefineFunction2() restriction list for function
  INPUTS       : None
  RETURNS      : A string containing the function restriction codes
  SIDE EFFECTS : EvaluationError set on errors
  NOTES        : None
 ********************************************************************/
void GetFunctionRestrictions(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   struct FunctionDefinition *fptr;
   char *stringBuffer = NULL;
   size_t bufferPosition = 0;
   size_t bufferMaximum = 0;

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
     { return; }
   
   returnValue->type = STRING;
   fptr = FindFunction(theEnv,DOToString(theArg));
   if (fptr == NULL)
     {
      CantFindItemErrorMessage(theEnv,"function",DOToString(theArg));
      EnvSetEvaluationError(theEnv,true);
      returnValue->value = EnvAddSymbol(theEnv,"");
      return;
     }

   if (fptr->minArgs == UNBOUNDED)
     {
      stringBuffer = AppendToString(theEnv,"0",
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   else
     {
      stringBuffer = AppendToString(theEnv,LongIntegerToString(theEnv,fptr->minArgs),
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   
   if (fptr->maxArgs == UNBOUNDED)
     {
      stringBuffer = AppendToString(theEnv,"*",
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   else
     {
      stringBuffer = AppendToString(theEnv,LongIntegerToString(theEnv,fptr->maxArgs),
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }

   if (fptr->restrictions == NULL)
     {
      stringBuffer = AppendToString(theEnv,"*",
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   else
     {
      stringBuffer = AppendToString(theEnv,ValueToString(fptr->restrictions),
                                    stringBuffer,&bufferPosition,&bufferMaximum);
     }
   
   returnValue->value = EnvAddSymbol(theEnv,stringBuffer);

   rm(theEnv,stringBuffer,bufferMaximum);
  }

/*************************************************/
/* GetFunctionListFunction: H/L access routine   */
/*   for the get-function-list function.         */
/*************************************************/
void GetFunctionListFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   struct FunctionDefinition *theFunction;
   Multifield *theList;
   unsigned long functionCount = 0;

   for (theFunction = GetFunctionList(theEnv);
        theFunction != NULL;
        theFunction = theFunction->next)
     { functionCount++; }

   SetpType(returnValue,MULTIFIELD);
   SetpDOBegin(returnValue,1);
   SetpDOEnd(returnValue,functionCount);
   theList = EnvCreateMultifield(theEnv,functionCount);
   SetpValue(returnValue,theList);

   for (theFunction = GetFunctionList(theEnv), functionCount = 1;
        theFunction != NULL;
        theFunction = theFunction->next, functionCount++)
     {
      SetMFType(theList,functionCount,SYMBOL);
      SetMFValue(theList,functionCount,theFunction->callFunctionName);
     }
  }

/***************************************/
/* FuncallFunction: H/L access routine */
/*   for the funcall function.         */
/***************************************/
void FuncallFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int j;
   CLIPSValue theArg;
   FUNCTION_REFERENCE theReference;
   const char *name;
   struct multifield *theMultifield;
   struct expr *lastAdd = NULL, *nextAdd, *multiAdd;
   struct FunctionDefinition *theFunction;
    
   /*==================================*/
   /* Set up the default return value. */
   /*==================================*/
   
   SetpType(returnValue,SYMBOL);
   SetpValue(returnValue,EnvFalseSymbol(theEnv));
   
   /*============================================*/
   /* Get the name of the function to be called. */
   /*============================================*/
   
   if (! UDFFirstArgument(context,LEXEME_TYPES,&theArg))
     { return; }
   
   /*====================*/
   /* Find the function. */
   /*====================*/

   name = DOToString(theArg);
   if (! GetFunctionReference(theEnv,name,&theReference))
     {
      ExpectedTypeError1(theEnv,"funcall",1,"function, deffunction, or generic function name");
      return; 
     }
     
   /*====================================*/
   /* Functions with specialized parsers */
   /* cannot be used with funcall.       */
   /*====================================*/

   if (theReference.type == FCALL)
     {
      theFunction = FindFunction(theEnv,name);
      if (theFunction->parser != NULL)
        {
         ExpectedTypeError1(theEnv,"funcall",1,"function without specialized parser");
         return; 
        }
     }

   /*======================================*/
   /* Add the arguments to the expression. */
   /*======================================*/
     
   ExpressionInstall(theEnv,&theReference);

   while (UDFHasNextArgument(context))
     {
      if (! UDFNextArgument(context,ANY_TYPE,&theArg))
        {
         ExpressionDeinstall(theEnv,&theReference);
         return; 
        }
      
      switch(GetType(theArg))
        {
         case MULTIFIELD:
           nextAdd = GenConstant(theEnv,FCALL,FindFunction(theEnv,"create$"));

           if (lastAdd == NULL)
             { theReference.argList = nextAdd; }
           else
             { lastAdd->nextArg = nextAdd; }
           lastAdd = nextAdd;

           multiAdd = NULL;
           theMultifield = (struct multifield *) GetValue(theArg);
           for (j = GetDOBegin(theArg); j <= GetDOEnd(theArg); j++)
             {
              nextAdd = GenConstant(theEnv,GetMFType(theMultifield,j),GetMFValue(theMultifield,j));
              if (multiAdd == NULL)
                { lastAdd->argList = nextAdd; }
              else
                { multiAdd->nextArg = nextAdd; }
              multiAdd = nextAdd;
             }

           ExpressionInstall(theEnv,lastAdd);
           break;
         
         default:
           nextAdd = GenConstant(theEnv,GetType(theArg),GetValue(theArg));
           if (lastAdd == NULL)
             { theReference.argList = nextAdd; }
           else
             { lastAdd->nextArg = nextAdd; }
           lastAdd = nextAdd;
           ExpressionInstall(theEnv,lastAdd);
           break;    
        }
     }

   /*===========================================================*/
   /* Verify a deffunction has the correct number of arguments. */
   /*===========================================================*/

#if DEFFUNCTION_CONSTRUCT
   if (theReference.type == PCALL)
     {
      if (CheckDeffunctionCall(theEnv,theReference.value,CountArguments(theReference.argList)) == false)
        {
         PrintErrorID(theEnv,"MISCFUN",4,false);
         EnvPrintRouter(theEnv,WERROR,"Function funcall called with the wrong number of arguments for deffunction ");
         EnvPrintRouter(theEnv,WERROR,EnvGetDeffunctionName(theEnv,theReference.value));
         EnvPrintRouter(theEnv,WERROR,"\n");
         ExpressionDeinstall(theEnv,&theReference);   
         ReturnExpression(theEnv,theReference.argList);
         return;
        }
     }
#endif
     
   /*=========================================*/
   /* Verify the correct number of arguments. */
   /*=========================================*/

// TBD Support run time check of arguments
#if ! RUN_TIME
   if (theReference.type == FCALL)
     {
      if (CheckExpressionAgainstRestrictions(theEnv,&theReference,theFunction,name))
        {
         ExpressionDeinstall(theEnv,&theReference);
         ReturnExpression(theEnv,theReference.argList);
         return;
        }
     }
#endif

   /*======================*/
   /* Call the expression. */
   /*======================*/
   
   EvaluateExpression(theEnv,&theReference,returnValue);
   
   /*========================================*/
   /* Return the expression data structures. */
   /*========================================*/
   
   ExpressionDeinstall(theEnv,&theReference);
   ReturnExpression(theEnv,theReference.argList);
  }
  
/***********************************/
/* NewFunction: H/L access routine */
/*   for the new function.         */
/***********************************/
void NewFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int theType;
   CLIPSValue theValue;
   const char *name;
    
   /*==================================*/
   /* Set up the default return value. */
   /*==================================*/
   
   SetpType(returnValue,SYMBOL);
   SetpValue(returnValue,EnvFalseSymbol(theEnv));
      
   /*====================================*/
   /* Get the name of the language type. */
   /*====================================*/
   
   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theValue))
     { return; }
   
   /*=========================*/
   /* Find the language type. */
   /*=========================*/

   name = DOToString(theValue);
   
   theType = FindLanguageType(theEnv,name);
   
   if (theType == -1)
     {
      ExpectedTypeError1(theEnv,"new",1,"external language");
      return; 
     }

   /*====================================================*/
   /* Invoke the new function for the specific language. */
   /*====================================================*/
   
   if ((EvaluationData(theEnv)->ExternalAddressTypes[theType] != NULL) &&
       (EvaluationData(theEnv)->ExternalAddressTypes[theType]->newFunction != NULL))
     { (*EvaluationData(theEnv)->ExternalAddressTypes[theType]->newFunction)(context,returnValue); }
  }
  
/************************************/
/* CallFunction: H/L access routine */
/*   for the new function.          */
/************************************/
void CallFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   int theType;
   CLIPSValue theValue;
   const char *name;
   struct externalAddressHashNode *theEA;
    
   /*==================================*/
   /* Set up the default return value. */
   /*==================================*/
   
   SetpType(returnValue,SYMBOL);
   SetpValue(returnValue,EnvFalseSymbol(theEnv));
   
   /*=========================*/
   /* Get the first argument. */
   /*=========================*/
   
   if (! UDFFirstArgument(context,SYMBOL_TYPE | EXTERNAL_ADDRESS_TYPE,&theValue))
     { return; }

   /*============================================*/
   /* If the first argument is a symbol, then it */
   /* should be an external language type.       */
   /*============================================*/
   
   if (GetType(theValue) == SYMBOL)
     { 
      name = DOToString(theValue);
      
      theType = FindLanguageType(theEnv,name);
      
      if (theType == -1)
        { 
         ExpectedTypeError1(theEnv,"call",1,"external language symbol or external address");
         return;
        }

      /*====================================================================*/
      /* Invoke the call function for the specific language. Typically this */
      /* will invoke a static method of a class (specified with the third   */
      /* and second arguments to the call function.                         */
      /*====================================================================*/
      
      if ((EvaluationData(theEnv)->ExternalAddressTypes[theType] != NULL) &&
          (EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction != NULL))
        { (*EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction)(context,&theValue,returnValue); }
        
      return;
     }

   /*===============================================*/
   /* If the first argument is an external address, */
   /* then we can determine the external language   */
   /* type be examining the pointer.                */
   /*===============================================*/
   
   if (GetType(theValue) == EXTERNAL_ADDRESS)
     { 
      theEA = (struct externalAddressHashNode *) GetValue(theValue);
      
      theType = theEA->type;
      
      if ((EvaluationData(theEnv)->ExternalAddressTypes[theType] != NULL) &&
          (EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction != NULL))
        { (*EvaluationData(theEnv)->ExternalAddressTypes[theType]->callFunction)(context,&theValue,returnValue); }
        
      return;
     }
  }

/*********************/
/* FindLanguageType: */
/*********************/
static int FindLanguageType(
  Environment *theEnv,
  const char *languageName)
  {
   int theType;
   
   for (theType = 0; theType < EvaluationData(theEnv)->numberOfAddressTypes; theType++)
     {
      if (strcmp(EvaluationData(theEnv)->ExternalAddressTypes[theType]->name,languageName) == 0)
        { return(theType); }
     }
     
   return -1;
  }
     
/************************************/
/* TimeFunction: H/L access routine */
/*   for the time function.         */
/************************************/
void TimeFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   /*==================*/
   /* Return the time. */
   /*==================*/

   returnValue->type = FLOAT;
   returnValue->value = EnvAddDouble(theEnv,gentime());
  }

/****************************************/
/* ConvertTime: Function for converting */
/*   time for local-time and gm-time.   */
/****************************************/
static void ConvertTime(
  Environment *theEnv,
  CLIPSValue *returnValue,
  struct tm *info)
  {
   returnValue->type = MULTIFIELD;
   returnValue->begin = 0;
   returnValue->end = 8;
   returnValue->value = EnvCreateMultifield(theEnv,9L);
   SetMFType(returnValue->value,1,INTEGER);
   SetMFValue(returnValue->value,1,EnvAddLong(theEnv,info->tm_year + 1900));
   SetMFType(returnValue->value,2,INTEGER);
   SetMFValue(returnValue->value,2,EnvAddLong(theEnv,info->tm_mon + 1));
   SetMFType(returnValue->value,3,INTEGER);
   SetMFValue(returnValue->value,3,EnvAddLong(theEnv,info->tm_mday));
   SetMFType(returnValue->value,4,INTEGER);
   SetMFValue(returnValue->value,4,EnvAddLong(theEnv,info->tm_hour));
   SetMFType(returnValue->value,5,INTEGER);
   SetMFValue(returnValue->value,5,EnvAddLong(theEnv,info->tm_min));
   SetMFType(returnValue->value,6,INTEGER);
   SetMFValue(returnValue->value,6,EnvAddLong(theEnv,info->tm_sec));

   SetMFType(returnValue->value,7,SYMBOL);
   switch (info->tm_wday)
     {
      case 0:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Sunday"));
        break;
        
      case 1:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Monday"));
        break;
        
      case 2:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Tuesday"));
        break;
        
      case 3:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Wednesday"));
        break;
        
      case 4:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Thursday"));
        break;
        
      case 5:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Friday"));
        break;
        
      case 6:
        SetMFValue(returnValue->value,7,EnvAddSymbol(theEnv,"Saturday"));
        break;
     }

   SetMFType(returnValue->value,8,INTEGER);
   SetMFValue(returnValue->value,8,EnvAddLong(theEnv,info->tm_yday));

   SetMFType(returnValue->value,9,SYMBOL);
   if (info->tm_isdst > 0)
     { SetMFValue(returnValue->value,9,SymbolData(theEnv)->TrueSymbolHN); }
   else if (info->tm_isdst == 0)
     { SetMFValue(returnValue->value,9,SymbolData(theEnv)->FalseSymbolHN); }
   else
     { SetMFValue(returnValue->value,9,EnvAddSymbol(theEnv,"UNKNOWN")); }
  }

/*****************************************/
/* LocalTimeFunction: H/L access routine */
/*   for the local-time function.        */
/*****************************************/
void LocalTimeFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   time_t rawtime;
   struct tm *info;

   /*=====================*/
   /* Get the local time. */
   /*=====================*/
   
   time(&rawtime);
   info = localtime(&rawtime);
   
   ConvertTime(theEnv,returnValue,info);
  }

/**************************************/
/* GMTimeFunction: H/L access routine */
/*   for the gm-time function.        */
/**************************************/
void GMTimeFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   time_t rawtime;
   struct tm *info;

   /*=====================*/
   /* Get the local time. */
   /*=====================*/
   
   time(&rawtime);
   info = gmtime(&rawtime);
   
   ConvertTime(theEnv,returnValue,info);
  }

/***************************************/
/* TimerFunction: H/L access routine   */
/*   for the timer function.           */
/***************************************/
void TimerFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   double startTime;
   CLIPSValue theArg;

   startTime = gentime();
   
   while (UDFHasNextArgument(context) &&
          (! EnvGetHaltExecution(theEnv)))
     { UDFNextArgument(context,ANY_TYPE,&theArg); }

   returnValue->type = FLOAT;
   returnValue->value = EnvAddDouble(theEnv,gentime() - startTime);
  }

/***************************************/
/* SystemCommand: H/L access routine   */
/*   for the system function.          */
/***************************************/
void SystemCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   char *commandBuffer = NULL;
   size_t bufferPosition = 0;
   size_t bufferMaximum = 0;
   CLIPSValue tempValue;
   const char *theString;

   /*============================================================*/
   /* Concatenate the arguments together to form a single string */
   /* containing the command to be sent to the operating system. */
   /*============================================================*/

   while (UDFHasNextArgument(context))
     {
      if (! UDFNextArgument(context,LEXEME_TYPES,&tempValue))
        { return; }

     theString = DOToString(tempValue);

     commandBuffer = AppendToString(theEnv,theString,commandBuffer,&bufferPosition,&bufferMaximum);
    }

   if (commandBuffer == NULL) return;

   /*=======================================*/
   /* Execute the operating system command. */
   /*=======================================*/

   gensystem(theEnv,commandBuffer);

   /*==================================================*/
   /* Return the string buffer containing the command. */
   /*==================================================*/

   rm(theEnv,commandBuffer,bufferMaximum);

   return;
  }
