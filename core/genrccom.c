   /*******************************************************/
   /*      "C" Language Integrated Production System      */
   /*                                                     */
   /*            CLIPS Version 6.40  08/25/16             */
   /*                                                     */
   /*                                                     */
   /*******************************************************/

/*************************************************************/
/* Purpose: Generic Functions Interface Routines             */
/*                                                           */
/* Principal Programmer(s):                                  */
/*      Brian L. Dantes                                      */
/*                                                           */
/* Contributing Programmer(s):                               */
/*                                                           */
/* Revision History:                                         */
/*      6.23: Correction for FalseSymbol/TrueSymbol. DR0859  */
/*                                                           */
/*            Corrected compilation errors for files         */
/*            generated by constructs-to-c. DR0861           */
/*                                                           */
/*            Changed name of variable log to logName        */
/*            because of Unix compiler warnings of shadowed  */
/*            definitions.                                   */
/*                                                           */
/*      6.24: Removed IMPERATIVE_METHODS compilation flag.   */
/*                                                           */
/*            Renamed BOOLEAN macro type to intBool.         */
/*                                                           */
/*            Corrected code to remove run-time program      */
/*            compiler warning.                              */
/*                                                           */
/*      6.30: Removed conditional code for unsupported       */
/*            compilers/operating systems (IBM_MCW,          */
/*            MAC_MCW, and IBM_TBC).                         */
/*                                                           */
/*            Changed integer type/precision.                */
/*                                                           */
/*            Added const qualifiers to remove C++           */
/*            deprecation warnings.                          */
/*                                                           */
/*            Converted API macros to function calls.        */
/*                                                           */
/*            Fixed linkage issue when DEBUGGING_FUNCTIONS   */
/*            is set to 0 and PROFILING_FUNCTIONS is set to  */
/*            1.                                             */
/*                                                           */
/*            Changed find construct functionality so that   */
/*            imported modules are search when locating a    */
/*            named construct.                               */
/*                                                           */
/*            Added code to keep track of pointers to        */
/*            constructs that are contained externally to    */
/*            to constructs, DanglingConstructs.             */
/*                                                           */
/*      6.40: Added Env prefix to GetEvaluationError and     */
/*            SetEvaluationError functions.                  */
/*                                                           */
/*            Pragma once and other inclusion changes.       */
/*                                                           */
/*            Added support for booleans with <stdbool.h>.   */
/*                                                           */
/*            Removed use of void pointers for specific      */
/*            data structures.                               */
/*                                                           */
/*            ALLOW_ENVIRONMENT_GLOBALS no longer supported. */
/*                                                           */
/*            UDF redesign.                                  */
/*                                                           */
/*************************************************************/

/* =========================================
   *****************************************
               EXTERNAL DEFINITIONS
   =========================================
   ***************************************** */
#include "setup.h"

#if DEFGENERIC_CONSTRUCT

#include <string.h>

#include "argacces.h"
#if BLOAD || BLOAD_AND_BSAVE
#include "bload.h"
#endif
#if OBJECT_SYSTEM
#include "classcom.h"
#include "inscom.h"
#endif
#include "constrct.h"
#include "cstrcpsr.h"
#include "envrnmnt.h"
#include "extnfunc.h"
#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
#include "genrcbin.h"
#endif
#if CONSTRUCT_COMPILER
#include "genrccmp.h"
#endif
#include "genrcexe.h"
#if (! BLOAD_ONLY) && (! RUN_TIME)
#include "genrcpsr.h"
#endif
#include "memalloc.h"
#include "modulpsr.h"
#include "multifld.h"
#include "router.h"
#if DEBUGGING_FUNCTIONS
#include "watch.h"
#endif

#include "genrccom.h"

/* =========================================
   *****************************************
      INTERNALLY VISIBLE FUNCTION HEADERS
   =========================================
   ***************************************** */

   static void                    PrintGenericCall(Environment *,const char *,Defgeneric *);
   static bool                    EvaluateGenericCall(Environment *,Defgeneric *,CLIPSValue *);
   static void                    DecrementGenericBusyCount(Environment *,Defgeneric *);
   static void                    IncrementGenericBusyCount(Environment *,Defgeneric *);
   static void                    DeallocateDefgenericData(Environment *);

#if ! RUN_TIME
   static void                    DestroyDefgenericAction(Environment *,struct constructHeader *,void *);
#endif

#if (! BLOAD_ONLY) && (! RUN_TIME)

   static void                    SaveDefgenerics(Environment *,Defmodule *,const char *);
   static void                    SaveDefmethods(Environment *,Defmodule *,const char *);
   static void                    SaveDefmethodsForDefgeneric(Environment *,struct constructHeader *,void *);
   static void                    RemoveDefgenericMethod(Environment *,Defgeneric *,long);

#endif

#if DEBUGGING_FUNCTIONS
   static long                    ListMethodsForGeneric(Environment *,const char *,Defgeneric *);
   static bool                    DefgenericWatchAccess(Environment *,int,bool,EXPRESSION *);
   static bool                    DefgenericWatchPrint(Environment *,const char *,int,EXPRESSION *);
   static bool                    DefmethodWatchAccess(Environment *,int,bool,EXPRESSION *);
   static bool                    DefmethodWatchPrint(Environment *,const char *,int,EXPRESSION *);
   static bool                    DefmethodWatchSupport(Environment *,const char *,const char *,bool,
                                                        void (*)(Environment *,const char *,Defgeneric *,long),
                                                        void (*)(Environment *,bool,Defgeneric *,long),
                                                        EXPRESSION *);
   static void                    PrintMethodWatchFlag(Environment *,const char *,Defgeneric *,long);
#endif

/* =========================================
   *****************************************
          EXTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/***********************************************************
  NAME         : SetupGenericFunctions
  DESCRIPTION  : Initializes all generic function
                   data structures, constructs and functions
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Generic function H/L functions set up
  NOTES        : None
 ***********************************************************/
void SetupGenericFunctions(
  Environment *theEnv)
  {
   ENTITY_RECORD genericEntityRecord =
                     { "GCALL", GCALL,0,0,1,
                       (EntityPrintFunction *) PrintGenericCall,
                       (EntityPrintFunction *) PrintGenericCall,
                       NULL,
                       (EntityEvaluationFunction *) EvaluateGenericCall,
                       NULL,
                       (EntityBusyCountFunction *) DecrementGenericBusyCount,
                       (EntityBusyCountFunction *) IncrementGenericBusyCount,
                       NULL,NULL,NULL,NULL,NULL };

   AllocateEnvironmentData(theEnv,DEFGENERIC_DATA,sizeof(struct defgenericData),DeallocateDefgenericData);
   memcpy(&DefgenericData(theEnv)->GenericEntityRecord,&genericEntityRecord,sizeof(struct entityRecord));

   InstallPrimitive(theEnv,&DefgenericData(theEnv)->GenericEntityRecord,GCALL);

   DefgenericData(theEnv)->DefgenericModuleIndex =
                RegisterModuleItem(theEnv,"defgeneric",
#if (! RUN_TIME)
                                    AllocateDefgenericModule,
                                    FreeDefgenericModule,
#else
                                    NULL,NULL,
#endif
#if BLOAD_AND_BSAVE || BLOAD || BLOAD_ONLY
                                    BloadDefgenericModuleReference,
#else
                                    NULL,
#endif
#if CONSTRUCT_COMPILER && (! RUN_TIME)
                                    DefgenericCModuleReference,
#else
                                    NULL,
#endif
                                    (FindConstructFunction *) EnvFindDefgenericInModule);

   DefgenericData(theEnv)->DefgenericConstruct =  AddConstruct(theEnv,"defgeneric","defgenerics",
#if (! BLOAD_ONLY) && (! RUN_TIME)
                                       ParseDefgeneric,
#else
                                       NULL,
#endif
                                       (FindConstructFunction *) EnvFindDefgeneric,
                                       GetConstructNamePointer,GetConstructPPForm,
                                       GetConstructModuleItem,
                                       (GetNextConstructFunction *) EnvGetNextDefgeneric,
                                       SetNextConstruct,
                                       (IsConstructDeletableFunction *) EnvIsDefgenericDeletable,
                                       (DeleteConstructFunction *) EnvUndefgeneric,
#if (! BLOAD_ONLY) && (! RUN_TIME)
                                       (FreeConstructFunction *) RemoveDefgeneric
#else
                                       NULL
#endif
                                       );


#if ! RUN_TIME
   AddClearReadyFunction(theEnv,"defgeneric",ClearDefgenericsReady,0);

#if BLOAD || BLOAD_ONLY || BLOAD_AND_BSAVE
   SetupGenericsBload(theEnv);
#endif

#if CONSTRUCT_COMPILER
   SetupGenericsCompiler(theEnv);
#endif

#if ! BLOAD_ONLY
#if DEFMODULE_CONSTRUCT
   AddPortConstructItem(theEnv,"defgeneric",SYMBOL_TOKEN);
#endif
   AddConstruct(theEnv,"defmethod","defmethods",ParseDefmethod,
                NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);

  /* ================================================================
     Make sure defmethods are cleared last, for other constructs may
       be using them and need to be cleared first

     Need to be cleared in two stages so that mutually dependent
       constructs (like classes) can be cleared
     ================================================================ */
   AddSaveFunction(theEnv,"defgeneric",SaveDefgenerics,1000);
   AddSaveFunction(theEnv,"defmethod",SaveDefmethods,-1000);
   EnvAddUDF(theEnv,"undefgeneric","v",1,1,"y",UndefgenericCommand,"UndefgenericCommand",NULL);
   EnvAddUDF(theEnv,"undefmethod","v",2,2,"*;y;ly",UndefmethodCommand,"UndefmethodCommand",NULL);
#endif

   EnvAddUDF(theEnv,"call-next-method","*",0,0,NULL,CallNextMethod,"CallNextMethod",NULL);
   FuncSeqOvlFlags(theEnv,"call-next-method",true,false);
   EnvAddUDF(theEnv,"call-specific-method","*",2,UNBOUNDED,"*;y;l",CallSpecificMethod,"CallSpecificMethod",NULL);
   FuncSeqOvlFlags(theEnv,"call-specific-method",true,false);
   EnvAddUDF(theEnv,"override-next-method","*",0,UNBOUNDED,NULL,OverrideNextMethod,"OverrideNextMethod",NULL);
   FuncSeqOvlFlags(theEnv,"override-next-method",true,false);
   EnvAddUDF(theEnv,"next-methodp","b",0,0,NULL,NextMethodPCommand,"NextMethodP",NULL);
   FuncSeqOvlFlags(theEnv,"next-methodp",true,false);

   EnvAddUDF(theEnv,"(gnrc-current-arg)","*",0,UNBOUNDED,NULL,GetGenericCurrentArgument,"GetGenericCurrentArgument",NULL);

#if DEBUGGING_FUNCTIONS
   EnvAddUDF(theEnv,"ppdefgeneric","v",1,1,"y",PPDefgenericCommand,"PPDefgenericCommand",NULL);
   EnvAddUDF(theEnv,"list-defgenerics","v",0,1,"y",ListDefgenericsCommand,"ListDefgenericsCommand",NULL);
   EnvAddUDF(theEnv,"ppdefmethod","v",2,2,"*;y;l",PPDefmethodCommand,"PPDefmethodCommand",NULL);
   EnvAddUDF(theEnv,"list-defmethods","v",0,1,"y",ListDefmethodsCommand,"ListDefmethodsCommand",NULL);
   EnvAddUDF(theEnv,"preview-generic","v",1,UNBOUNDED,"*;y",PreviewGeneric,"PreviewGeneric",NULL);
#endif

   EnvAddUDF(theEnv,"get-defgeneric-list","m",0,1,"y",GetDefgenericListFunction,"GetDefgenericListFunction",NULL);
   EnvAddUDF(theEnv,"get-defmethod-list","m",0,1,"y",GetDefmethodListCommand,"GetDefmethodListCommand",NULL);
   EnvAddUDF(theEnv,"get-method-restrictions","m",2,2,"l;y",GetMethodRestrictionsCommand,"GetMethodRestrictionsCommand",NULL);
   EnvAddUDF(theEnv,"defgeneric-module","y",1,1,"y",GetDefgenericModuleCommand,"GetDefgenericModuleCommand",NULL);

#if OBJECT_SYSTEM
   EnvAddUDF(theEnv,"type","*",1,1,"*",ClassCommand,"ClassCommand",NULL);
#else
   EnvAddUDF(theEnv,"type","*",1,1,"*",TypeCommand,"TypeCommand",NULL);
#endif

#endif

#if DEBUGGING_FUNCTIONS
   AddWatchItem(theEnv,"generic-functions",0,&DefgenericData(theEnv)->WatchGenerics,34,
                DefgenericWatchAccess,DefgenericWatchPrint);
   AddWatchItem(theEnv,"methods",0,&DefgenericData(theEnv)->WatchMethods,33,
                DefmethodWatchAccess,DefmethodWatchPrint);
#endif
  }

/*****************************************************/
/* DeallocateDefgenericData: Deallocates environment */
/*    data for the defgeneric construct.             */
/*****************************************************/
static void DeallocateDefgenericData(
  Environment *theEnv)
  {
#if ! RUN_TIME
   struct defgenericModule *theModuleItem;
   Defmodule *theModule;

#if BLOAD || BLOAD_AND_BSAVE
   if (Bloaded(theEnv)) return;
#endif

   DoForAllConstructs(theEnv,
                      DestroyDefgenericAction,
                      DefgenericData(theEnv)->DefgenericModuleIndex,false,NULL);

   for (theModule = EnvGetNextDefmodule(theEnv,NULL);
        theModule != NULL;
        theModule = EnvGetNextDefmodule(theEnv,theModule))
     {
      theModuleItem = (struct defgenericModule *)
                      GetModuleItem(theEnv,theModule,
                                    DefgenericData(theEnv)->DefgenericModuleIndex);

      rtn_struct(theEnv,defgenericModule,theModuleItem);
     }
#else
#if MAC_XCD
#pragma unused(theEnv)
#endif
#endif
  }

#if ! RUN_TIME
/****************************************************/
/* DestroyDefgenericAction: Action used to remove   */
/*   defgenerics as a result of DestroyEnvironment. */
/****************************************************/
static void DestroyDefgenericAction(
  Environment *theEnv,
  struct constructHeader *theConstruct,
  void *buffer)
  {
#if MAC_XCD
#pragma unused(buffer)
#endif
#if (! BLOAD_ONLY) && (! RUN_TIME)
   Defgeneric *theDefgeneric = (Defgeneric *) theConstruct;
   long i;

   if (theDefgeneric == NULL) return;

   for (i = 0 ; i < theDefgeneric->mcnt ; i++)
     { DestroyMethodInfo(theEnv,theDefgeneric,&theDefgeneric->methods[i]); }

   if (theDefgeneric->mcnt != 0)
     { rm(theEnv,theDefgeneric->methods,(sizeof(Defmethod) * theDefgeneric->mcnt)); }

   DestroyConstructHeader(theEnv,&theDefgeneric->header);

   rtn_struct(theEnv,defgeneric,theDefgeneric);
#else
#if MAC_XCD
#pragma unused(theEnv,theConstruct)
#endif
#endif
  }
#endif

/***************************************************
  NAME         : EnvFindDefgeneric
  DESCRIPTION  : Searches for a generic
  INPUTS       : The name of the generic
                 (possibly including a module name)
  RETURNS      : Pointer to the generic if
                 found, otherwise NULL
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
Defgeneric *EnvFindDefgeneric(
  Environment *theEnv,
  const char *genericModuleAndName)
  {
   return (Defgeneric *) FindNamedConstructInModuleOrImports(theEnv,genericModuleAndName,DefgenericData(theEnv)->DefgenericConstruct);
  }

/***************************************************
  NAME         : EnvFindDefgenericInModule
  DESCRIPTION  : Searches for a generic
  INPUTS       : The name of the generic
                 (possibly including a module name)
  RETURNS      : Pointer to the generic if
                 found, otherwise NULL
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
Defgeneric *EnvFindDefgenericInModule(
  Environment *theEnv,
  const char *genericModuleAndName)
  {
   return (Defgeneric *) FindNamedConstructInModule(theEnv,genericModuleAndName,DefgenericData(theEnv)->DefgenericConstruct);
  }

/***************************************************
  NAME         : LookupDefgenericByMdlOrScope
  DESCRIPTION  : Finds a defgeneric anywhere (if
                 module is specified) or in current
                 or imported modules
  INPUTS       : The defgeneric name
  RETURNS      : The defgeneric (NULL if not found)
  SIDE EFFECTS : Error message printed on
                  ambiguous references
  NOTES        : None
 ***************************************************/
Defgeneric *LookupDefgenericByMdlOrScope(
  Environment *theEnv,
  const char *defgenericName)
  {
   return (Defgeneric *) LookupConstruct(theEnv,DefgenericData(theEnv)->DefgenericConstruct,defgenericName,true);
  }

/***************************************************
  NAME         : LookupDefgenericInScope
  DESCRIPTION  : Finds a defgeneric in current or
                   imported modules (module
                   specifier is not allowed)
  INPUTS       : The defgeneric name
  RETURNS      : The defgeneric (NULL if not found)
  SIDE EFFECTS : Error message printed on
                  ambiguous references
  NOTES        : None
 ***************************************************/
Defgeneric *LookupDefgenericInScope(
  Environment *theEnv,
  const char *defgenericName)
  {
   return (Defgeneric *) LookupConstruct(theEnv,DefgenericData(theEnv)->DefgenericConstruct,defgenericName,false);
  }

/***********************************************************
  NAME         : EnvGetNextDefgeneric
  DESCRIPTION  : Finds first or next generic function
  INPUTS       : The address of the current generic function
  RETURNS      : The address of the next generic function
                   (NULL if none)
  SIDE EFFECTS : None
  NOTES        : If ptr == NULL, the first generic function
                    is returned.
 ***********************************************************/
Defgeneric *EnvGetNextDefgeneric(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   return (Defgeneric *) GetNextConstructItem(theEnv,(struct constructHeader *) theDefgeneric,DefgenericData(theEnv)->DefgenericModuleIndex);
  }

/***********************************************************
  NAME         : EnvGetNextDefmethod
  DESCRIPTION  : Find the next method for a generic function
  INPUTS       : 1) The generic function address
                 2) The index of the current method
  RETURNS      : The index of the next method
                    (0 if none)
  SIDE EFFECTS : None
  NOTES        : If index == 0, the index of the first
                   method is returned
 ***********************************************************/
long EnvGetNextDefmethod(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  long theIndex)
  {
   long mi;
#if MAC_XCD
#pragma unused(theEnv)
#endif

   if (theIndex == 0)
     {
      if (theDefgeneric->methods != NULL)
        return(theDefgeneric->methods[0].index);
      return 0;
     }
   mi = FindMethodByIndex(theDefgeneric,theIndex);
   if ((mi+1) == theDefgeneric->mcnt)
     { return 0; }
   return theDefgeneric->methods[mi+1].index;
  }

/*****************************************************
  NAME         : GetDefmethodPointer
  DESCRIPTION  : Returns a pointer to a method
  INPUTS       : 1) Pointer to a defgeneric
                 2) Array index of method in generic's
                    method array (+1)
  RETURNS      : Pointer to the method.
  SIDE EFFECTS : None
  NOTES        : None
 *****************************************************/
Defmethod *GetDefmethodPointer(
  Defgeneric *theDefgeneric,
  long theIndex)
  {
   return &theDefgeneric->methods[theIndex-1];
  }

/***************************************************
  NAME         : EnvIsDefgenericDeletable
  DESCRIPTION  : Determines if a generic function
                   can be deleted
  INPUTS       : Address of the generic function
  RETURNS      : True if deletable, false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
bool EnvIsDefgenericDeletable(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   if (! ConstructsDeletable(theEnv))
     { return false; }

   return (theDefgeneric->busy == 0) ? true : false;
  }

/***************************************************
  NAME         : EnvIsDefmethodDeletable
  DESCRIPTION  : Determines if a generic function
                   method can be deleted
  INPUTS       : 1) Address of the generic function
                 2) Index of the method
  RETURNS      : True if deletable, false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
bool EnvIsDefmethodDeletable(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  long theIndex)
  {
   if (! ConstructsDeletable(theEnv))
     { return false; }

   if (theDefgeneric->methods[FindMethodByIndex(theDefgeneric,theIndex)].system)
     return false;

#if (! BLOAD_ONLY) && (! RUN_TIME)
   return (MethodsExecuting(theDefgeneric) == false) ? true : false;
#else
   return false;
#endif
  }

/**********************************************************
  NAME         : UndefgenericCommand
  DESCRIPTION  : Deletes all methods for a generic function
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : methods deallocated
  NOTES        : H/L Syntax: (undefgeneric <name> | *)
 **********************************************************/
void UndefgenericCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   UndefconstructCommand(context,"undefgeneric",DefgenericData(theEnv)->DefgenericConstruct);
  }

/****************************************************************
  NAME         : GetDefgenericModuleCommand
  DESCRIPTION  : Determines to which module a defgeneric belongs
  INPUTS       : None
  RETURNS      : The symbolic name of the module
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (defgeneric-module <generic-name>)
 ****************************************************************/
void GetDefgenericModuleCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   returnValue->value = GetConstructModuleCommand(context,"defgeneric-module",DefgenericData(theEnv)->DefgenericConstruct);
  }

/**************************************************************
  NAME         : UndefmethodCommand
  DESCRIPTION  : Deletes one method for a generic function
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : methods deallocated
  NOTES        : H/L Syntax: (undefmethod <name> <index> | *)
 **************************************************************/
void UndefmethodCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   Defgeneric *gfunc;
   long mi;

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg)) return;

   gfunc = LookupDefgenericByMdlOrScope(theEnv,theArg.lexemeValue->contents);
   if ((gfunc == NULL) ? (strcmp(theArg.lexemeValue->contents,"*") != 0) : false)
     {
      PrintErrorID(theEnv,"GENRCCOM",1,false);
      EnvPrintRouter(theEnv,WERROR,"No such generic function ");
      EnvPrintRouter(theEnv,WERROR,theArg.lexemeValue->contents);
      EnvPrintRouter(theEnv,WERROR," in function undefmethod.\n");
      return;
     }

   if (! UDFNextArgument(context,ANY_TYPE,&theArg)) return;

   if (CVIsType(&theArg,SYMBOL_TYPE))
     {
      if (strcmp(theArg.lexemeValue->contents,"*") != 0)
        {
         PrintErrorID(theEnv,"GENRCCOM",2,false);
         EnvPrintRouter(theEnv,WERROR,"Expected a valid method index in function undefmethod.\n");
         return;
        }
      mi = 0;
     }
   else if (CVIsType(&theArg,INTEGER_TYPE))
     {
      mi = (long) theArg.integerValue->contents;
      if (mi == 0)
        {
         PrintErrorID(theEnv,"GENRCCOM",2,false);
         EnvPrintRouter(theEnv,WERROR,"Expected a valid method index in function undefmethod.\n");
         return;
        }
     }
   else
     {
      PrintErrorID(theEnv,"GENRCCOM",2,false);
      EnvPrintRouter(theEnv,WERROR,"Expected a valid method index in function undefmethod.\n");
      return;
     }
   EnvUndefmethod(theEnv,gfunc,mi);
  }

/**************************************************************
  NAME         : EnvUndefgeneric
  DESCRIPTION  : Deletes all methods for a generic function
  INPUTS       : The generic-function address (NULL for all)
  RETURNS      : True if generic successfully deleted,
                 false otherwise
  SIDE EFFECTS : methods deallocated
  NOTES        : None
 **************************************************************/
bool EnvUndefgeneric(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
#if RUN_TIME || BLOAD_ONLY
   return false;
#else
   bool success = true;

   if (theDefgeneric == NULL)
     {
      if (ClearDefmethods(theEnv) == false)
        success = false;
      if (ClearDefgenerics(theEnv) == false)
        success = false;
      return(success);
     }
   if (EnvIsDefgenericDeletable(theEnv,theDefgeneric) == false)
     return false;
   RemoveConstructFromModule(theEnv,(struct constructHeader *) theDefgeneric);
   RemoveDefgeneric(theEnv,theDefgeneric);
   return true;
#endif
  }

/**************************************************************
  NAME         : EnvUndefmethod
  DESCRIPTION  : Deletes one method for a generic function
  INPUTS       : 1) Address of generic function (can be NULL)
                 2) Method index (0 for all)
  RETURNS      : True if method deleted successfully,
                 false otherwise
  SIDE EFFECTS : methods deallocated
  NOTES        : None
 **************************************************************/
bool EnvUndefmethod(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  long mi)
  {
#if RUN_TIME || BLOAD_ONLY
   PrintErrorID(theEnv,"PRNTUTIL",4,false);
   EnvPrintRouter(theEnv,WERROR,"Unable to delete method ");
   if (theDefgeneric != NULL)
     {
      PrintGenericName(theEnv,WERROR,theDefgeneric);
      EnvPrintRouter(theEnv,WERROR," #");
      PrintLongInteger(theEnv,WERROR,(long long) mi);
     }
   else
     EnvPrintRouter(theEnv,WERROR,"*");
   EnvPrintRouter(theEnv,WERROR,".\n");
   return false;
#else
   long nmi;

#if BLOAD || BLOAD_AND_BSAVE
   if (Bloaded(theEnv) == true)
     {
      PrintErrorID(theEnv,"PRNTUTIL",4,false);
      EnvPrintRouter(theEnv,WERROR,"Unable to delete method ");
      if (theDefgeneric != NULL)
        {
         EnvPrintRouter(theEnv,WERROR,EnvGetDefgenericName(theEnv,theDefgeneric));
         EnvPrintRouter(theEnv,WERROR," #");
         PrintLongInteger(theEnv,WERROR,(long long) mi);
        }
      else
        EnvPrintRouter(theEnv,WERROR,"*");
      EnvPrintRouter(theEnv,WERROR,".\n");
      return false;
     }
#endif
   if (theDefgeneric == NULL)
     {
      if (mi != 0)
        {
         PrintErrorID(theEnv,"GENRCCOM",3,false);
         EnvPrintRouter(theEnv,WERROR,"Incomplete method specification for deletion.\n");
         return false;
        }
      return(ClearDefmethods(theEnv));
     }
   if (MethodsExecuting(theDefgeneric))
     {
      MethodAlterError(theEnv,theDefgeneric);
      return false;
     }
   if (mi == 0)
     RemoveAllExplicitMethods(theEnv,theDefgeneric);
   else
     {
      nmi = CheckMethodExists(theEnv,"undefmethod",theDefgeneric,mi);
      if (nmi == -1)
        return false;
      RemoveDefgenericMethod(theEnv,theDefgeneric,nmi);
     }
   return true;
#endif
  }

#if DEBUGGING_FUNCTIONS || PROFILING_FUNCTIONS

/*****************************************************
  NAME         : EnvGetDefmethodDescription
  DESCRIPTION  : Prints a synopsis of method parameter
                   restrictions into caller's buffer
  INPUTS       : 1) Caller's buffer
                 2) Buffer size (not including space
                    for terminating '\0')
                 3) Address of generic function
                 4) Index of method
  RETURNS      : Nothing useful
  SIDE EFFECTS : Caller's buffer written
  NOTES        : Terminating '\n' not written
 *****************************************************/
void EnvGetDefmethodDescription(
  Environment *theEnv,
  char *buf,
  size_t buflen,
  Defgeneric *theDefgeneric,
  long theIndex)
  {
   long mi;
#if MAC_XCD
#pragma unused(theEnv)
#endif

   mi = FindMethodByIndex(theDefgeneric,theIndex);
   PrintMethod(theEnv,buf,buflen,&theDefgeneric->methods[mi]);
  }
#endif /* DEBUGGING_FUNCTIONS || PROFILING_FUNCTIONS */

#if DEBUGGING_FUNCTIONS

/*********************************************************
  NAME         : EnvGetDefgenericWatch
  DESCRIPTION  : Determines if trace messages are
                 gnerated when executing generic function
  INPUTS       : A pointer to the generic
  RETURNS      : True if a trace is active,
                 false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 *********************************************************/
bool EnvGetDefgenericWatch(
  Environment *theEnv,
  Defgeneric *theGeneric)
  {
#if MAC_XCD
#pragma unused(theEnv)
#endif

   return theGeneric->trace;
  }

/*********************************************************
  NAME         : EnvSetDefgenericWatch
  DESCRIPTION  : Sets the trace to ON/OFF for the
                 generic function
  INPUTS       : 1) True to set the trace on,
                    False to set it off
                 2) A pointer to the generic
  RETURNS      : Nothing useful
  SIDE EFFECTS : Watch flag for the generic set
  NOTES        : None
 *********************************************************/
void EnvSetDefgenericWatch(
  Environment *theEnv,
  bool newState,
  Defgeneric *theGeneric)
  {
#if MAC_XCD
#pragma unused(theEnv)
#endif

   theGeneric->trace = newState;
  }

/*********************************************************
  NAME         : EnvGetDefmethodWatch
  DESCRIPTION  : Determines if trace messages for calls
                 to this method will be generated or not
  INPUTS       : 1) A pointer to the generic
                 2) The index of the method
  RETURNS      : True if a trace is active,
                 false otherwise
  SIDE EFFECTS : None
  NOTES        : None
 *********************************************************/
bool EnvGetDefmethodWatch(
  Environment *theEnv,
  Defgeneric *theGeneric,
  long theIndex)
  {
   long mi;
#if MAC_XCD
#pragma unused(theEnv)
#endif

   mi = FindMethodByIndex(theGeneric,theIndex);
   return theGeneric->methods[mi].trace;
  }

/*********************************************************
  NAME         : EnvSetDefmethodWatch
  DESCRIPTION  : Sets the trace to ON/OFF for the
                 calling of the method
  INPUTS       : 1) True to set the trace on,
                    false to set it off
                 2) A pointer to the generic
                 3) The index of the method
  RETURNS      : Nothing useful
  SIDE EFFECTS : Watch flag for the method set
  NOTES        : None
 *********************************************************/
void EnvSetDefmethodWatch(
  Environment *theEnv,
  bool newState,
  Defgeneric *theGeneric,
  long theIndex)
  {
   long mi;
#if MAC_XCD
#pragma unused(theEnv)
#endif

   mi = FindMethodByIndex(theGeneric,theIndex);
   theGeneric->methods[mi].trace = newState;
  }


/********************************************************
  NAME         : PPDefgenericCommand
  DESCRIPTION  : Displays the pretty-print form of
                  a generic function header
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (ppdefgeneric <name>)
 ********************************************************/
void PPDefgenericCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   PPConstructCommand(context,"ppdefgeneric",DefgenericData(theEnv)->DefgenericConstruct);
  }

/**********************************************************
  NAME         : PPDefmethodCommand
  DESCRIPTION  : Displays the pretty-print form of
                  a method
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (ppdefmethod <name> <index>)
 **********************************************************/
void PPDefmethodCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   const char *gname;
   Defgeneric *gfunc;
   int gi;

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg)) return;
   gname = theArg.lexemeValue->contents;

   if (! UDFNextArgument(context,INTEGER_TYPE,&theArg)) return;

   gfunc = CheckGenericExists(theEnv,"ppdefmethod",gname);
   if (gfunc == NULL)
     return;
   gi = CheckMethodExists(theEnv,"ppdefmethod",gfunc,(long) theArg.integerValue->contents);
   if (gi == -1)
     return;
   if (gfunc->methods[gi].header.ppForm != NULL)
     PrintInChunks(theEnv,WDISPLAY,gfunc->methods[gi].header.ppForm);
  }

/******************************************************
  NAME         : ListDefmethodsCommand
  DESCRIPTION  : Lists a brief description of methods
                   for a particular generic function
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (list-defmethods <name>)
 ******************************************************/
void ListDefmethodsCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   Defgeneric *gfunc;

   if (! UDFHasNextArgument(context))
     { EnvListDefmethods(theEnv,WDISPLAY,NULL); }
   else
     {
      if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg)) return;

      gfunc = CheckGenericExists(theEnv,"list-defmethods",theArg.lexemeValue->contents);
      if (gfunc != NULL)
        { EnvListDefmethods(theEnv,WDISPLAY,gfunc); }
     }
  }

/***************************************************************
  NAME         : EnvGetDefmethodPPForm
  DESCRIPTION  : Getsa generic function method pretty print form
  INPUTS       : 1) Address of the generic function
                 2) Index of the method
  RETURNS      : Method ppform
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************************/
const char *EnvGetDefmethodPPForm(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  long theIndex)
  {
   int mi;
#if MAC_XCD
#pragma unused(theEnv)
#endif

   mi = FindMethodByIndex(theDefgeneric,theIndex);
   return theDefgeneric->methods[mi].header.ppForm;
  }

/***************************************************
  NAME         : ListDefgenericsCommand
  DESCRIPTION  : Displays all defgeneric names
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : Defgeneric names printed
  NOTES        : H/L Interface
 ***************************************************/
void ListDefgenericsCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   ListConstructCommand(context,DefgenericData(theEnv)->DefgenericConstruct);
  }

/***************************************************
  NAME         : EnvListDefgenerics
  DESCRIPTION  : Displays all defgeneric names
  INPUTS       : 1) The logical name of the output
                 2) The module
  RETURNS      : Nothing useful
  SIDE EFFECTS : Defgeneric names printed
  NOTES        : C Interface
 ***************************************************/
void EnvListDefgenerics(
  Environment *theEnv,
  const char *logicalName,
  Defmodule *theModule)
  {
   ListConstruct(theEnv,DefgenericData(theEnv)->DefgenericConstruct,logicalName,theModule);
  }

/******************************************************
  NAME         : EnvListDefmethods
  DESCRIPTION  : Lists a brief description of methods
                   for a particular generic function
  INPUTS       : 1) The logical name of the output
                 2) Generic function to list methods for
                    (NULL means list all methods)
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : None
 ******************************************************/
void EnvListDefmethods(
  Environment *theEnv,
  const char *logicalName,
  Defgeneric *theDefgeneric)
  {
   Defgeneric *gfunc;
   long count;
   if (theDefgeneric != NULL)
     count = ListMethodsForGeneric(theEnv,logicalName,theDefgeneric);
   else
     {
      count = 0L;
      for (gfunc = EnvGetNextDefgeneric(theEnv,NULL) ;
           gfunc != NULL ;
           gfunc = EnvGetNextDefgeneric(theEnv,gfunc))
        {
         count += ListMethodsForGeneric(theEnv,logicalName,gfunc);
         if (EnvGetNextDefgeneric(theEnv,gfunc) != NULL)
           EnvPrintRouter(theEnv,logicalName,"\n");
        }
     }
   PrintTally(theEnv,logicalName,count,"method","methods");
  }

#endif /* DEBUGGING_FUNCTIONS */

/***************************************************************
  NAME         : GetDefgenericListFunction
  DESCRIPTION  : Groups all defgeneric names into
                 a multifield list
  INPUTS       : A data object buffer to hold
                 the multifield result
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : H/L Syntax: (get-defgeneric-list [<module>])
 ***************************************************************/
void GetDefgenericListFunction(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   GetConstructListFunction(context,returnValue,DefgenericData(theEnv)->DefgenericConstruct);
  }

/***************************************************************
  NAME         : EnvGetDefgenericList
  DESCRIPTION  : Groups all defgeneric names into
                 a multifield list
  INPUTS       : 1) A data object buffer to hold
                    the multifield result
                 2) The module from which to obtain defgenerics
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield allocated and filled
  NOTES        : External C access
 ***************************************************************/
void EnvGetDefgenericList(
  Environment *theEnv,
  CLIPSValue *returnValue,
  Defmodule *theModule)
  {
   GetConstructList(theEnv,returnValue,DefgenericData(theEnv)->DefgenericConstruct,theModule);
  }

/***********************************************************
  NAME         : GetDefmethodListCommand
  DESCRIPTION  : Groups indices of all methdos for a generic
                 function into a multifield variable
                 (NULL means get methods for all generics)
  INPUTS       : A data object buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield set to list of method indices
  NOTES        : None
 ***********************************************************/
void GetDefmethodListCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   Defgeneric *gfunc;

   if (! UDFHasNextArgument(context))
     { EnvGetDefmethodList(theEnv,NULL,returnValue); }
   else
     {
      if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
        { return; }
      gfunc = CheckGenericExists(theEnv,"get-defmethod-list",theArg.lexemeValue->contents);
      if (gfunc != NULL)
        { EnvGetDefmethodList(theEnv,gfunc,returnValue); }
      else
        { EnvSetMultifieldErrorValue(theEnv,returnValue); }
     }
  }

/***********************************************************
  NAME         : EnvGetDefmethodList
  DESCRIPTION  : Groups indices of all methdos for a generic
                 function into a multifield variable
                 (NULL means get methods for all generics)
  INPUTS       : 1) A pointer to a generic function
                 2) A data object buffer
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield set to list of method indices
  NOTES        : None
 ***********************************************************/
void EnvGetDefmethodList(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  CLIPSValue *returnValue)
  {
   Defgeneric *gfunc, *svg, *svnxt;
   long i,j;
   unsigned long count;
   Multifield *theList;

   if (theDefgeneric != NULL)
     {
      gfunc = theDefgeneric;
      svnxt = EnvGetNextDefgeneric(theEnv,theDefgeneric);
      SetNextDefgeneric(theDefgeneric,NULL);
     }
   else
     {
      gfunc = EnvGetNextDefgeneric(theEnv,NULL);
      svnxt = (gfunc != NULL) ? EnvGetNextDefgeneric(theEnv,gfunc) : NULL;
     }
   count = 0;
   for (svg = gfunc ;
        gfunc != NULL ;
        gfunc = EnvGetNextDefgeneric(theEnv,gfunc))
     count += (unsigned long) gfunc->mcnt;
   count *= 2;
   returnValue->begin = 0;
   returnValue->end = count - 1;
   theList = (Multifield *) EnvCreateMultifield(theEnv,count);
   returnValue->value = theList;
   for (gfunc = svg , i = 0 ;
        gfunc != NULL ;
        gfunc = EnvGetNextDefgeneric(theEnv,gfunc))
     {
      for (j = 0 ; j < gfunc->mcnt ; j++)
        {
         SetMFValue(theList,i++,GetDefgenericNamePointer(gfunc));
         SetMFValue(theList,i++,EnvCreateInteger(theEnv,(long long) gfunc->methods[j].index));
        }
     }
   if (svg != NULL)
     SetNextDefgeneric(svg,svnxt);
  }

/***********************************************************************************
  NAME         : GetMethodRestrictionsCommand
  DESCRIPTION  : Stores restrictions of a method in multifield
  INPUTS       : A data object buffer to hold a multifield
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield created (length zero on errors)
  NOTES        : Syntax: (get-method-restrictions <generic-function> <method-index>)
 ***********************************************************************************/
void GetMethodRestrictionsCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   CLIPSValue theArg;
   Defgeneric *gfunc;

   if (! UDFFirstArgument(context,SYMBOL_TYPE,&theArg))
     { return; }
   gfunc = CheckGenericExists(theEnv,"get-method-restrictions",theArg.lexemeValue->contents);
   if (gfunc == NULL)
     {
      EnvSetMultifieldErrorValue(theEnv,returnValue);
      return;
     }

   if (! UDFNextArgument(context,INTEGER_TYPE,&theArg))
     { return; }

   if (CheckMethodExists(theEnv,"get-method-restrictions",gfunc,(long) theArg.integerValue->contents) == -1)
     {
      EnvSetMultifieldErrorValue(theEnv,returnValue);
      return;
     }
   EnvGetMethodRestrictions(theEnv,gfunc,(unsigned) theArg.integerValue->contents,returnValue);
  }

/***********************************************************************
  NAME         : EnvGetMethodRestrictions
  DESCRIPTION  : Stores restrictions of a method in multifield
  INPUTS       : 1) Pointer to the generic function
                 2) The method index
                 3) A data object buffer to hold a multifield
  RETURNS      : Nothing useful
  SIDE EFFECTS : Multifield created (length zero on errors)
  NOTES        : The restrictions are stored in the multifield
                 in the following format:

                 <min-number-of-arguments>
                 <max-number-of-arguments> (-1 if wildcard allowed)
                 <restriction-count>
                 <index of 1st restriction>
                       .
                       .
                 <index of nth restriction>
                 <restriction 1>
                     <query TRUE/FALSE>
                     <number-of-classes>
                     <class 1>
                        .
                        .
                     <class n>
                    .
                    .
                    .
                  <restriction n>

                  Thus, for the method
                  (defmethod foo ((?a NUMBER SYMBOL) (?b (= 1 1)) $?c))
                  (get-method-restrictions foo 1) would yield

                  (2 -1 3 7 11 13 FALSE 2 NUMBER SYMBOL TRUE 0 FALSE 0)
 ***********************************************************************/
void EnvGetMethodRestrictions(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  long mi,
  CLIPSValue *returnValue)
  {
   short i,j;
   Defmethod *meth;
   RESTRICTION *rptr;
   long count;
   int roffset,rstrctIndex;
   Multifield *theList;

   meth = theDefgeneric->methods + FindMethodByIndex(theDefgeneric,mi);
   count = 3;
   for (i = 0 ; i < meth->restrictionCount ; i++)
     count += meth->restrictions[i].tcnt + 3;
   theList = (Multifield *) EnvCreateMultifield(theEnv,count);

   returnValue->value = theList;
   returnValue->begin = 0;
   returnValue->end = count - 1;
   SetMFValue(theList,0,EnvCreateInteger(theEnv,(long long) meth->minRestrictions));
   SetMFValue(theList,1,EnvCreateInteger(theEnv,(long long) meth->maxRestrictions));
   SetMFValue(theList,2,EnvCreateInteger(theEnv,(long long) meth->restrictionCount));
   roffset = 3 + meth->restrictionCount;
   rstrctIndex = 3;
   for (i = 0 ; i < meth->restrictionCount ; i++)
     {
      rptr = meth->restrictions + i;
      SetMFValue(theList,rstrctIndex++,EnvCreateInteger(theEnv,(long long) roffset + 1));
      SetMFValue(theList,roffset++,(rptr->query != NULL) ? theEnv->TrueSymbol : theEnv->FalseSymbol);
      SetMFValue(theList,roffset++,EnvCreateInteger(theEnv,(long long) rptr->tcnt));
      for (j = 0 ; j < rptr->tcnt ; j++)
        {
#if OBJECT_SYSTEM
         SetMFValue(theList,roffset++,EnvCreateSymbol(theEnv,EnvGetDefclassName(theEnv,(Defclass *) rptr->types[j])));
#else
         SetMFValue(theList,roffset++,EnvCreateSymbol(theEnv,TypeName(theEnv,ValueToInteger(rptr->types[j]))));
#endif
        }
     }
  }

/* =========================================
   *****************************************
          INTERNALLY VISIBLE FUNCTIONS
   =========================================
   ***************************************** */

/***************************************************
  NAME         : PrintGenericCall
  DESCRIPTION  : PrintExpression() support function
                 for generic function calls
  INPUTS       : 1) The output logical name
                 2) The generic function
  RETURNS      : Nothing useful
  SIDE EFFECTS : Call expression printed
  NOTES        : None
 ***************************************************/
static void PrintGenericCall(
  Environment *theEnv,
  const char *logName,
  Defgeneric *theDefgeneric)
  {
#if DEVELOPER

   EnvPrintRouter(theEnv,logName,"(");
   EnvPrintRouter(theEnv,logName,EnvGetDefgenericName(theEnv,theDefgeneric));
   if (GetFirstArgument() != NULL)
     {
      EnvPrintRouter(theEnv,logName," ");
      PrintExpression(theEnv,logName,GetFirstArgument());
     }
   EnvPrintRouter(theEnv,logName,")");
#else
#if MAC_XCD
#pragma unused(theEnv)
#pragma unused(logName)
#pragma unused(theDefgeneric)
#endif
#endif
  }

/*******************************************************
  NAME         : EvaluateGenericCall
  DESCRIPTION  : Primitive support function for
                 calling a generic function
  INPUTS       : 1) The generic function
                 2) A data object buffer to hold
                    the evaluation result
  RETURNS      : False if the generic function
                 returns the symbol false,
                 true otherwise
  SIDE EFFECTS : Data obejct buffer set and any
                 side-effects of calling the generic
  NOTES        : None
 *******************************************************/
static bool EvaluateGenericCall(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  CLIPSValue *returnValue)
  {
   GenericDispatch(theEnv,theDefgeneric,NULL,NULL,GetFirstArgument(),returnValue);
   if ((returnValue->header->type == SYMBOL) &&
       (returnValue->value == theEnv->FalseSymbol))
     return false;
   return true;
  }

/***************************************************
  NAME         : DecrementGenericBusyCount
  DESCRIPTION  : Lowers the busy count of a
                 generic function construct
  INPUTS       : The generic function
  RETURNS      : Nothing useful
  SIDE EFFECTS : Busy count decremented if a clear
                 is not in progress (see comment)
  NOTES        : None
 ***************************************************/
static void DecrementGenericBusyCount(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   /* ==============================================
      The generics to which expressions in other
      constructs may refer may already have been
      deleted - thus, it is important not to modify
      the busy flag during a clear.
      ============================================== */
   if (! ConstructData(theEnv)->ClearInProgress)
     { theDefgeneric->busy--; }
  }

/***************************************************
  NAME         : IncrementGenericBusyCount
  DESCRIPTION  : Raises the busy count of a
                 generic function construct
  INPUTS       : The generic function
  RETURNS      : Nothing useful
  SIDE EFFECTS : Busy count incremented
  NOTES        : None
 ***************************************************/
static void IncrementGenericBusyCount(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
#if MAC_XCD
#pragma unused(theEnv)
#endif
#if (! RUN_TIME) && (! BLOAD_ONLY)
   if (! ConstructData(theEnv)->ParsingConstruct)
     { ConstructData(theEnv)->DanglingConstructs++; }
#endif

   theDefgeneric->busy++;
  }

#if (! BLOAD_ONLY) && (! RUN_TIME)

/**********************************************************************
  NAME         : SaveDefgenerics
  DESCRIPTION  : Outputs pretty-print forms of generic function headers
  INPUTS       : The logical name of the output
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : None
 **********************************************************************/
static void SaveDefgenerics(
  Environment *theEnv,
  Defmodule *theModule,
  const char *logName)
  {
   SaveConstruct(theEnv,theModule,logName,DefgenericData(theEnv)->DefgenericConstruct);
  }

/**********************************************************************
  NAME         : SaveDefmethods
  DESCRIPTION  : Outputs pretty-print forms of generic function methods
  INPUTS       : The logical name of the output
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : None
 **********************************************************************/
static void SaveDefmethods(
  Environment *theEnv,
  Defmodule *theModule,
  const char *logName)
  {
   DoForAllConstructsInModule(theEnv,theModule,
                              SaveDefmethodsForDefgeneric,
                              DefgenericData(theEnv)->DefgenericModuleIndex,
                              false,(void *) logName);
  }

/***************************************************
  NAME         : SaveDefmethodsForDefgeneric
  DESCRIPTION  : Save the pretty-print forms of
                 all methods for a generic function
                 to a file
  INPUTS       : 1) The defgeneric
                 2) The logical name of the output
  RETURNS      : Nothing useful
  SIDE EFFECTS : Methods written
  NOTES        : None
 ***************************************************/
static void SaveDefmethodsForDefgeneric(
  Environment *theEnv,
  struct constructHeader *theDefgeneric,
  void *userBuffer)
  {
   Defgeneric *gfunc = (Defgeneric *) theDefgeneric;
   const char *logName = (const char *) userBuffer;
   long i;

   for (i = 0 ; i < gfunc->mcnt ; i++)
     {
      if (gfunc->methods[i].header.ppForm != NULL)
        {
         PrintInChunks(theEnv,logName,gfunc->methods[i].header.ppForm);
         EnvPrintRouter(theEnv,logName,"\n");
        }
     }
  }

/****************************************************
  NAME         : RemoveDefgenericMethod
  DESCRIPTION  : Removes a generic function method
                   from the array and removes the
                   generic too if its the last method
  INPUTS       : 1) The generic function
                 2) The array index of the method
  RETURNS      : Nothing useful
  SIDE EFFECTS : List adjusted
                 Nodes deallocated
  NOTES        : Assumes deletion is safe
 ****************************************************/
static void RemoveDefgenericMethod(
  Environment *theEnv,
  Defgeneric *gfunc,
  long gi)
  {
   Defmethod *narr;
   long b,e;

   if (gfunc->methods[gi].system)
     {
      EnvSetEvaluationError(theEnv,true);
      PrintErrorID(theEnv,"GENRCCOM",4,false);
      EnvPrintRouter(theEnv,WERROR,"Cannot remove implicit system function method for generic function ");
      EnvPrintRouter(theEnv,WERROR,EnvGetDefgenericName(theEnv,gfunc));
      EnvPrintRouter(theEnv,WERROR,".\n");
      return;
     }
   DeleteMethodInfo(theEnv,gfunc,&gfunc->methods[gi]);
   if (gfunc->mcnt == 1)
     {
      rm(theEnv,gfunc->methods,(int) sizeof(Defmethod));
      gfunc->mcnt = 0;
      gfunc->methods = NULL;
     }
   else
     {
      gfunc->mcnt--;
      narr = (Defmethod *) gm2(theEnv,(sizeof(Defmethod) * gfunc->mcnt));
      for (b = e = 0 ; b < gfunc->mcnt ; b++ , e++)
        {
         if (((int) b) == gi)
           e++;
         GenCopyMemory(Defmethod,1,&narr[b],&gfunc->methods[e]);
        }
      rm(theEnv,gfunc->methods,(sizeof(Defmethod) * (gfunc->mcnt+1)));
      gfunc->methods = narr;
     }
  }

#endif

#if DEBUGGING_FUNCTIONS

/******************************************************
  NAME         : ListMethodsForGeneric
  DESCRIPTION  : Lists a brief description of methods
                   for a particular generic function
  INPUTS       : 1) The logical name of the output
                 2) Generic function to list methods for
  RETURNS      : The number of methods printed
  SIDE EFFECTS : None
  NOTES        : None
 ******************************************************/
static long ListMethodsForGeneric(
  Environment *theEnv,
  const char *logicalName,
  Defgeneric *gfunc)
  {
   long gi;
   char buf[256];

   for (gi = 0 ; gi < gfunc->mcnt ; gi++)
     {
      EnvPrintRouter(theEnv,logicalName,EnvGetDefgenericName(theEnv,gfunc));
      EnvPrintRouter(theEnv,logicalName," #");
      PrintMethod(theEnv,buf,255,&gfunc->methods[gi]);
      EnvPrintRouter(theEnv,logicalName,buf);
      EnvPrintRouter(theEnv,logicalName,"\n");
     }
   return((long) gfunc->mcnt);
  }

/******************************************************************
  NAME         : DefgenericWatchAccess
  DESCRIPTION  : Parses a list of generic names passed by
                 AddWatchItem() and sets the traces accordingly
  INPUTS       : 1) A code indicating which trace flag is to be set
                    Ignored
                 2) The value to which to set the trace flags
                 3) A list of expressions containing the names
                    of the generics for which to set traces
  RETURNS      : True if all OK, false otherwise
  SIDE EFFECTS : Watch flags set in specified generics
  NOTES        : Accessory function for AddWatchItem()
 ******************************************************************/
static bool DefgenericWatchAccess(
  Environment *theEnv,
  int code,
  bool newState,
  EXPRESSION *argExprs)
  {
#if MAC_XCD
#pragma unused(code)
#endif

   return(ConstructSetWatchAccess(theEnv,DefgenericData(theEnv)->DefgenericConstruct,newState,argExprs,
                                  (bool (*)(Environment *,void *)) EnvGetDefgenericWatch,
                                  (void (*)(Environment *,bool,void *)) EnvSetDefgenericWatch));
  }

/***********************************************************************
  NAME         : DefgenericWatchPrint
  DESCRIPTION  : Parses a list of generic names passed by
                 AddWatchItem() and displays the traces accordingly
  INPUTS       : 1) The logical name of the output
                 2) A code indicating which trace flag is to be examined
                    Ignored
                 3) A list of expressions containing the names
                    of the generics for which to examine traces
  RETURNS      : True if all OK, false otherwise
  SIDE EFFECTS : Watch flags displayed for specified generics
  NOTES        : Accessory function for AddWatchItem()
 ***********************************************************************/
static bool DefgenericWatchPrint(
  Environment *theEnv,
  const char *logName,
  int code,
  EXPRESSION *argExprs)
  {
#if MAC_XCD
#pragma unused(code)
#endif

   return(ConstructPrintWatchAccess(theEnv,DefgenericData(theEnv)->DefgenericConstruct,logName,argExprs,
                                    (bool (*)(Environment *,void *)) EnvGetDefgenericWatch,
                                    (void (*)(Environment *,bool,void *)) EnvSetDefgenericWatch));
  }

/******************************************************************
  NAME         : DefmethodWatchAccess
  DESCRIPTION  : Parses a list of methods passed by
                 AddWatchItem() and sets the traces accordingly
  INPUTS       : 1) A code indicating which trace flag is to be set
                    Ignored
                 2) The value to which to set the trace flags
                 3) A list of expressions containing the methods
                   for which to set traces
  RETURNS      : True if all OK, false otherwise
  SIDE EFFECTS : Watch flags set in specified methods
  NOTES        : Accessory function for AddWatchItem()
 ******************************************************************/
static bool DefmethodWatchAccess(
  Environment *theEnv,
  int code,
  bool newState,
  EXPRESSION *argExprs)
  {
#if MAC_XCD
#pragma unused(code)
#endif
   if (newState)
     return(DefmethodWatchSupport(theEnv,"watch",NULL,newState,NULL,EnvSetDefmethodWatch,argExprs));
   else
     return(DefmethodWatchSupport(theEnv,"unwatch",NULL,newState,NULL,EnvSetDefmethodWatch,argExprs));
  }

/***********************************************************************
  NAME         : DefmethodWatchPrint
  DESCRIPTION  : Parses a list of methods passed by
                 AddWatchItem() and displays the traces accordingly
  INPUTS       : 1) The logical name of the output
                 2) A code indicating which trace flag is to be examined
                    Ignored
                 3) A list of expressions containing the methods for
                    which to examine traces
  RETURNS      : True if all OK, false otherwise
  SIDE EFFECTS : Watch flags displayed for specified methods
  NOTES        : Accessory function for AddWatchItem()
 ***********************************************************************/
static bool DefmethodWatchPrint(
  Environment *theEnv,
  const char *logName,
  int code,
  EXPRESSION *argExprs)
  {
#if MAC_XCD
#pragma unused(code)
#endif
   return(DefmethodWatchSupport(theEnv,"list-watch-items",logName,0,
                                PrintMethodWatchFlag,NULL,argExprs));
  }

/*******************************************************
  NAME         : DefmethodWatchSupport
  DESCRIPTION  : Sets or displays methods specified
  INPUTS       : 1) The calling function name
                 2) The logical output name for displays
                    (can be NULL)
                 3) The new set state
                 4) The print function (can be NULL)
                 5) The trace function (can be NULL)
                 6) The methods expression list
  RETURNS      : True if all OK,
                 false otherwise
  SIDE EFFECTS : Method trace flags set or displayed
  NOTES        : None
 *******************************************************/
static bool DefmethodWatchSupport(
  Environment *theEnv,
  const char *funcName,
  const char *logName,
  bool newState,
  void (*printFunc)(Environment *,const char *,Defgeneric *,long),
  void (*traceFunc)(Environment *,bool,Defgeneric *,long),
  EXPRESSION *argExprs)
  {
   Defgeneric *theGeneric;
   unsigned long theMethod = 0;
   int argIndex = 2;
   CLIPSValue genericName, methodIndex;
   Defmodule *theModule;

   /* ==============================
      If no methods are specified,
      show the trace for all methods
      in all generics
      ============================== */
   if (argExprs == NULL)
     {
      SaveCurrentModule(theEnv);
      theModule = EnvGetNextDefmodule(theEnv,NULL);
      while (theModule != NULL)
        {
         EnvSetCurrentModule(theEnv,theModule);
         if (traceFunc == NULL)
           {
            EnvPrintRouter(theEnv,logName,EnvGetDefmoduleName(theEnv,theModule));
            EnvPrintRouter(theEnv,logName,":\n");
           }
         theGeneric = EnvGetNextDefgeneric(theEnv,NULL);
         while (theGeneric != NULL)
            {
             theMethod = EnvGetNextDefmethod(theEnv,theGeneric,0);
             while (theMethod != 0)
               {
                if (traceFunc != NULL)
                  (*traceFunc)(theEnv,newState,theGeneric,theMethod);
                else
                  {
                   EnvPrintRouter(theEnv,logName,"   ");
                   (*printFunc)(theEnv,logName,theGeneric,theMethod);
                  }
                theMethod = EnvGetNextDefmethod(theEnv,theGeneric,theMethod);
               }
             theGeneric = EnvGetNextDefgeneric(theEnv,theGeneric);
            }
         theModule = EnvGetNextDefmodule(theEnv,theModule);
        }
      RestoreCurrentModule(theEnv);
      return true;
     }

   /* =========================================
      Set the traces for every method specified
      ========================================= */
   while (argExprs != NULL)
     {
      if (EvaluateExpression(theEnv,argExprs,&genericName))
        return false;
      if ((genericName.header->type != SYMBOL) ? true :
          ((theGeneric =
              LookupDefgenericByMdlOrScope(theEnv,genericName.lexemeValue->contents)) == NULL))
        {
         ExpectedTypeError1(theEnv,funcName,argIndex,"generic function name");
         return false;
        }
      if (GetNextArgument(argExprs) == NULL)
        theMethod = 0;
      else
        {
         argExprs = GetNextArgument(argExprs);
         argIndex++;
         if (EvaluateExpression(theEnv,argExprs,&methodIndex))
           return false;
         if ((methodIndex.header->type != INTEGER) ? false :
             ((methodIndex.integerValue->contents <= 0) ? false :
              (FindMethodByIndex(theGeneric,theMethod) != -1)))
           theMethod = (long) methodIndex.integerValue->contents;
         else
           {
            ExpectedTypeError1(theEnv,funcName,argIndex,"method index");
            return false;
           }
        }
      if (theMethod == 0)
        {
         theMethod = EnvGetNextDefmethod(theEnv,theGeneric,0);
         while (theMethod != 0)
           {
            if (traceFunc != NULL)
              (*traceFunc)(theEnv,newState,theGeneric,theMethod);
            else
              (*printFunc)(theEnv,logName,theGeneric,theMethod);
            theMethod = EnvGetNextDefmethod(theEnv,theGeneric,theMethod);
           }
        }
      else
        {
         if (traceFunc != NULL)
           (*traceFunc)(theEnv,newState,theGeneric,theMethod);
         else
           (*printFunc)(theEnv,logName,theGeneric,theMethod);
        }
      argExprs = GetNextArgument(argExprs);
      argIndex++;
     }
   return true;
  }

/***************************************************
  NAME         : PrintMethodWatchFlag
  DESCRIPTION  : Displays trace value for method
  INPUTS       : 1) The logical name of the output
                 2) The generic function
                 3) The method index
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : None
 ***************************************************/
static void PrintMethodWatchFlag(
  Environment *theEnv,
  const char *logName,
  Defgeneric *theGeneric,
  long theMethod)
  {
   char buf[60];

   EnvPrintRouter(theEnv,logName,EnvGetDefgenericName(theEnv,theGeneric));
   EnvPrintRouter(theEnv,logName," ");
   EnvGetDefmethodDescription(theEnv,buf,59,theGeneric,theMethod);
   EnvPrintRouter(theEnv,logName,buf);
   if (EnvGetDefmethodWatch(theEnv,theGeneric,theMethod))
     EnvPrintRouter(theEnv,logName," = on\n");
   else
     EnvPrintRouter(theEnv,logName," = off\n");
  }

#endif

#if ! OBJECT_SYSTEM

/***************************************************
  NAME         : TypeCommand
  DESCRIPTION  : Works like "class" in COOL
  INPUTS       : None
  RETURNS      : Nothing useful
  SIDE EFFECTS : None
  NOTES        : H/L Syntax: (type <primitive>)
 ***************************************************/
void TypeCommand(
  Environment *theEnv,
  UDFContext *context,
  CLIPSValue *returnValue)
  {
   EvaluateExpression(theEnv,GetFirstArgument(),result);

   returnValue->lexemeValue = EnvCreateSymbol(theEnv,TypeName(theEnv,result->type));
  }

#endif

/*#############################*/
/* Additional Access Functions */
/*#############################*/

CLIPSLexeme *GetDefgenericNamePointer(
  Defgeneric *theDefgeneric)
  {
   return GetConstructNamePointer((struct constructHeader *) theDefgeneric);
  }

void SetNextDefgeneric(
  Defgeneric *theDefgeneric,
  Defgeneric *targetDefgeneric)
  {
   SetNextConstruct((struct constructHeader *) theDefgeneric,
                    (struct constructHeader *) targetDefgeneric);
  }

/*##################################*/
/* Additional Environment Functions */
/*##################################*/

const char *EnvDefgenericModule(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   return GetConstructModuleName((struct constructHeader *) theDefgeneric);
  }

const char *EnvGetDefgenericName(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   return GetConstructNameString((struct constructHeader *) theDefgeneric);
  }

const char *EnvGetDefgenericPPForm(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   return GetConstructPPForm(theEnv,(struct constructHeader *) theDefgeneric);
  }

CLIPSLexeme *EnvGetDefgenericNamePointer(
  Environment *theEnv,
  Defgeneric *theDefgeneric)
  {
   return GetConstructNamePointer((struct constructHeader *) theDefgeneric);
  }

void EnvSetDefgenericPPForm(
  Environment *theEnv,
  Defgeneric *theDefgeneric,
  const char *thePPForm)
  {
   SetConstructPPForm(theEnv,(struct constructHeader *) theDefgeneric,thePPForm);
  }


#endif /* DEFGENERIC_CONSTRUCT */

